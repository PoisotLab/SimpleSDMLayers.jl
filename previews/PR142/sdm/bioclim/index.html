<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building the BIOCLIM model · Simple SDM Layers</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Simple SDM Layers logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Simple SDM Layers</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/types/">Types</a></li><li><a class="tocitem" href="../../man/indexing/">Indexing</a></li><li><a class="tocitem" href="../../man/clip/">Clipping</a></li><li><a class="tocitem" href="../../man/changevalues/">Operations on values</a></li><li><a class="tocitem" href="../../man/overloads/">Overloads</a></li><li><a class="tocitem" href="../../man/operations/">Other operations</a></li><li><a class="tocitem" href="../../man/data/">Data access</a></li><li><a class="tocitem" href="../../man/io/">IO</a></li></ul></li><li><span class="tocitem">General examples</span><ul><li><a class="tocitem" href="../../examples/elevation/">Introduction: elevation data</a></li><li><a class="tocitem" href="../../examples/geometry/">Geometry for clipping</a></li><li><a class="tocitem" href="../../examples/slidingwindow/">Sliding window analysis</a></li><li><a class="tocitem" href="../../examples/landcover/">Landcover data</a></li><li><a class="tocitem" href="../../examples/multivariate/">Multivariate mapping</a></li></ul></li><li><span class="tocitem">SDM case studies</span><ul><li><a class="tocitem" href="../gbif/">GBIF integration</a></li><li><a class="tocitem" href="../vif/">Variable selection (VIF)</a></li><li class="is-active"><a class="tocitem" href>Building the BIOCLIM model</a></li><li><a class="tocitem" href="../pseudoabsences/">Pseudo-absences</a></li><li><a class="tocitem" href="../future/">Dealing with future data</a></li><li><a class="tocitem" href="../brt/">BRTs and climate change</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">SDM case studies</a></li><li class="is-active"><a href>Building the BIOCLIM model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building the BIOCLIM model</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/bioclim.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Building-the-BIOCLIM-model"><a class="docs-heading-anchor" href="#Building-the-BIOCLIM-model">Building the BIOCLIM model</a><a id="Building-the-BIOCLIM-model-1"></a><a class="docs-heading-anchor-permalink" href="#Building-the-BIOCLIM-model" title="Permalink"></a></h1><p><strong>Justification for this use case:</strong> <code>SimpleSDMLayers</code> can be used as a platform to build your own species distribution models. In this example, which assumes that you have read the vignettes on GBIF integration and variable selection through VIF, we will build our own version of the BIOCLIM model, and apply it to the distribution of <em>Hypomyces lactifluorum</em> in North America.</p><pre><code class="language-julia hljs">using SimpleSDMLayers
using GBIF
using Plots
using GLM
using StatsBase
using Statistics
using GeometryBasics</code></pre><p>BIOCLIM is a very simple model, which only requires presence information. The first step is therefore to get occurrences of <em>Hypomyces lactifluorum</em> in North America. Because the data in GBIF is only as good as the original data source, sometimes searching by <code>continent</code> gives fewer results than searching by country.</p><pre><code class="language-julia hljs">observations = occurrences(
    GBIF.taxon(&quot;Hypomyces lactifluorum&quot;; strict=true),
    &quot;hasCoordinate&quot; =&gt; &quot;true&quot;,
    &quot;country&quot; =&gt; &quot;CA&quot;,
    &quot;country&quot; =&gt; &quot;US&quot;,
    &quot;limit&quot; =&gt; 300,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GBIF records: downloaded 300 out of 3523
</code></pre><p>We will now page through additional results (300 at a time).</p><pre><code class="language-julia hljs">while length(observations) &lt; size(observations)
    occurrences!(observations)
end</code></pre><p>At this point, we could read the whole predictor variables directly, and then clip them. This would be fairly wasteful, as we need a small area. For this reason, we will calculate the bounding box first, and then use it to only read the section we want.</p><pre><code class="language-julia hljs">left, right = extrema(longitudes(observations)) .+ (-5, 5)
bottom, top = extrema(latitudes(observations)) .+ (-5, 5)
boundaries = (left=left, right=right, bottom=bottom, top=top)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(left = -164.022167, right = -55.250858, bottom = 23.547132, top = 72.105833)</code></pre><p>With this information in hand, we can start getting our variables. In this example, we will take all of the BioClim data from WorldClim, at the 10 arc minute resolution, and add the elevation layer. Note that using the bounding box coordinates when calling the layers is <em>much</em> faster than clipping after the fact (assuming that you already have the files downloaded).</p><pre><code class="language- hljs">predictors =
    convert.(
        Float32, SimpleSDMPredictor(WorldClim, BioClim, 1:19; resolution=10.0, boundaries...)
    );
nothing #hide</code></pre><p>We will add the elevation to the stack of variables we use – we need to convert everything to <code>Float32</code> layers, because elevation is originally an <code>Int16</code> one and a number of operations we will make will require floating points</p><pre><code class="language- hljs">push!(
    predictors,
    convert(
        Float32, SimpleSDMPredictor(WorldClim, Elevation; resolution=10.0, boundaries...)
    ),
);
nothing #hide</code></pre><p>It is not a bad idea to plot all of the predictors:</p><pre><code class="language- hljs">plot(plot.(predictors, grid=:none, axes=false, frame=:none, leg=false, c=:imola)...)</code></pre><p>Clearly, some of them show strong autocorrelation; we will therefore re-use our VIF code to select a subset that has uncorrelated variables.</p><pre><code class="language-julia hljs">function vif(model)
    R² = r2(model)
    return 1 / (1-R²)
end

function stepwisevif(
    layers::Vector{T}, selection=collect(1:length(layers)), threshold::Float64=5.0
) where {T&lt;:SimpleSDMLayer}
    x = hcat([layer[keys(layer)] for layer in layers[selection]]...)
    X = (x .- mean(x; dims=1)) ./ std(x; dims=1)
    vifs = zeros(Float64, length(selection))
    for i in eachindex(selection)
        vifs[i] = vif(lm(X[:, setdiff(eachindex(selection), i)], X[:, i]))
    end
    all(vifs .&lt;= threshold) &amp;&amp; return selection
    drop = last(findmax(vifs))
    popat!(selection, drop)
    @info &quot;Variables remaining: $(selection)&quot;
    return stepwisevif(layers, selection, threshold)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">stepwisevif (generic function with 3 methods)</code></pre><p>We will apply this function with the default parameters:</p><pre><code class="language- hljs">layers_to_keep = stepwisevif(predictors)</code></pre><p>When this is done, we can plot  the layers again to check that they are all more or less unique:</p><pre><code class="language- hljs">plot(
    plot.(
        predictors[layers_to_keep], grid=:none, axes=false, frame=:none, leg=false, c=:imola
    )...,
)</code></pre><p>The point of BIOCLIM (the model, not the dataset) is that the score assigned to a pixel is maximal if this pixel is the <em>median</em> value for a given variable. Therefore, we need to measure the cumulative density function for every pixel in every variable, and transform it with:</p><pre><code class="language-julia hljs">_pixel_score(x) = 2.0(x &gt; 0.5 ? 1.0 - x : x);</code></pre><p>The <em>actual</em> model generation is fairly straightforward, as we will need to get the values of the layers in the cells occupied by an observation. Because sampling bias is very real, we will grid the observations by transforming them into a boolean layer:</p><pre><code class="language- hljs">presences = mask(predictors[1], observations, Bool)
plot(convert(Float32, presences); c=cgrad([:lightgrey, :black]), leg=false)</code></pre><p>This step is very important so as not to bias the estimation of quantiles, which overcounting observations within the same cell would do. We can now define the model:</p><pre><code class="language-julia hljs">function SDM(predictor::T1, observations::T2) where {T1&lt;:SimpleSDMLayer,T2&lt;:SimpleSDMLayer}
    _tmp = mask(observations, predictor)
    qf = ecdf(convert(Vector{Float32}, _tmp[keys(_tmp)])) # We only want the observed values
    return (_pixel_score ∘ qf)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SDM (generic function with 1 method)</code></pre><p>Note that we use the ∘ (<code>\circ</code>) operator to chain the quantile estimation and the pixel scoring, which requires Julia 1.4. This function returns a <em>model</em>, <em>i.e.</em> a function that we can broadcast to a given layer, which might not be the same one we used for the training.</p><p>The next step in BIOCLIM is to get the <em>minimum</em> suitability across all layers for every pixel. Because we have a <code>min</code> method defined for a pair of layers, we can call <code>minimum</code> on an array of layers:</p><pre><code class="language-julia hljs">function SDM(predictors::Vector{T}, models) where {T&lt;:SimpleSDMLayer}
    @assert length(models) == length(predictors)
    return minimum([broadcast(models[i], predictors[i]) for i in 1:length(predictors)])
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SDM (generic function with 2 methods)</code></pre><p>The advantage of this approach is that we can call the <code>SDM</code> method for prediction on a smaller layer, or a different layer. This can allow us to do thing like stitching layers together with <code>hcat</code> and <code>vcat</code> to use multi-threading, or use a different resolution for the prediction than we did for the training.</p><pre><code class="language- hljs">models = [SDM(predictor, presences) for predictor in predictors];
nothing #hide</code></pre><p>We now get the prediction:</p><pre><code class="language- hljs">prediction = SDM(predictors, models)</code></pre><p>It&#39;s not a bad idea to look at this prediction, to get a sense of where the hotspots of presence would be:</p><pre><code class="language- hljs">plot(prediction; c=:bamako, frame=:box)
xaxis!(&quot;Longitude&quot;)
yaxis!(&quot;Latitude&quot;)</code></pre><p>Just because we may want to visualize this result in a transformed way, <em>i.e.</em> by looking at the quantiles of suitability, we can call the <code>rescale</code> function:</p><pre><code class="language- hljs">prediction_quantile = rescale(prediction, collect(0.0:0.005:1.0))</code></pre><p>As this map now represents the quantiles of suitability, we may want to remove the lower 5%. For this, we need to create a boolean mask, which we can do by broadcasting a conditional:</p><pre><code class="language- hljs">cutoff = broadcast(x -&gt; x &gt; 0.05, prediction_quantile)</code></pre><p>The raw prediction, minus the 5% bottom quantiles, can the be plotted:</p><pre><code class="language- hljs">plot(prediction; frame=:box, c=:lightgrey)
plot!(mask(cutoff, prediction); c=:bamako)
xaxis!(&quot;Longitude&quot;)
yaxis!(&quot;Latitude&quot;)</code></pre><p>And there it is! A simple way to write the BIOCLIM model by building on the integration between SimpleSDMLayers and GBIF. BIOCLIM has a tendency to underfit the distribution quite a bit - in fact, the range returned here is larger than what other methods (like BRT) would return. The next vignettes in this section will be focused on using additional functionalities of <code>SimpleSDMLayers</code> until we are able to make a better model for this species.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vif/">« Variable selection (VIF)</a><a class="docs-footer-nextpage" href="../pseudoabsences/">Pseudo-absences »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Sunday 24 July 2022 15:35">Sunday 24 July 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
