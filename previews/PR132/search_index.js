var documenterSearchIndex = {"docs":
[{"location":"man/clip/#Clipping-and-stitching-rasters","page":"Clipping","title":"Clipping and stitching rasters","text":"","category":"section"},{"location":"man/clip/","page":"Clipping","title":"Clipping","text":"clip","category":"page"},{"location":"man/clip/#SimpleSDMLayers.clip","page":"Clipping","title":"SimpleSDMLayers.clip","text":"clip(layer::T, p1::Point, p2::Point) where {T <: SimpleSDMLayer}\n\nReturn a raster by defining a bounding box through two points. The order of the points (in terms of bottom/top/left/right) is not really important, as the correct coordinates will be extracted.\n\n\n\n\n\nclip(layer::T; left=nothing, right=nothing, top=nothing, bottom=nothing) where {T <: SimpleSDMLayer}\n\nClips a raster by giving the (optional) limites left, right, bottom, and top.\n\n\n\n\n\nclip(origin::T1, destination::T2) where {T1 <: SimpleSDMLayer, T2 <: SimpleSDMLayer}\n\nClips a layer by another layer, i.e. subsets the first layer so that it has the dimensions of the second layer. This operation applies a very small displacement to the limits (5eps()) to ensure that if the coordinate to cut at falls exactly on a cell boundary, the correct cell will be used in the return layer.\n\n\n\n\n\nclip(layer::T, records::GBIF.GBIFRecords)\n\nReturns a clipped version (with a 10% margin) around all occurences in a GBIFRecords collection.\n\n\n\n\n\n","category":"function"},{"location":"man/clip/","page":"Clipping","title":"Clipping","text":"Base.vcat\nBase.hcat","category":"page"},{"location":"man/clip/#Base.vcat","page":"Clipping","title":"Base.vcat","text":"Base.vcat(l1::T, l2::T) where {T <: SimpleSDMLayers}\n\nAdds the second layer under the first one (according to coordinates),  assuming the strides and left/right coordinates match. This will automatically re-order the layers if the second is above the first.\n\n\n\n\n\n","category":"function"},{"location":"man/clip/#Base.hcat","page":"Clipping","title":"Base.hcat","text":"Base.hcat(l1::T, l2::T) where {T <: SimpleSDMLayers}\n\nAdds the second layer to the right of the first one (according to coordinates), assuming the strides and left/right coordinates match. This will automatically  re-order the layers if the second is to the left the first.\n\n\n\n\n\n","category":"function"},{"location":"man/clip/","page":"Clipping","title":"Clipping","text":"mosaic","category":"page"},{"location":"man/clip/#SimpleSDMLayers.mosaic","page":"Clipping","title":"SimpleSDMLayers.mosaic","text":"mosaic(f::TF, layers::Vector{T}) where {TF <: Function, T <: SimpleSDMLayer}\n\nJoins a series of possibly overlapping layers by applying the function f to the values that occupy the same cells. Note that the function f  should return a single value and accept an vector as input. Functions like Statistics.mean, etc, work well.\n\nUsing mosaic with maximum is equivalent to raster::merge from the R package raster.\n\n\n\n\n\n","category":"function"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/slidingwindow.jl\"","category":"page"},{"location":"examples/slidingwindow/#Sliding-window-analysis","page":"Sliding window analysis","title":"Sliding window analysis","text":"","category":"section"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"In this example, we will get precipitation data from Québec, and use a sliding window analysis to smooth them out. The beginning of the code should now be familiar:","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"using SimpleSDMLayers\nusing Plots\nusing Statistics","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"precipitation = SimpleSDMPredictor(WorldClim, BioClim, 12; left=-80.0, right=-56.0, bottom=44.0, top=62.0)","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"The sliding window works by taking all pixels within a given radius (expressed in kilometres) around the pixel of interest, and then applying the function given as the second argument to their values. Empty pixels are removed. In this case, we will do a summary across a 100 km radius around each pixel:","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"averaged = slidingwindow(precipitation, Statistics.mean, 100.0; threaded=false)","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"We can finally overlap the two layers – the result of sliding window is a little bit smoother than the raw data.","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"plot(precipitation, c=:alpine)\ncontour!(averaged, c=:white, lw=2.0)","category":"page"},{"location":"man/overloads/#Methods-overloaded","page":"Overloads","title":"Methods overloaded","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"To facilitate writing julian code, we have overloaded a number of methods from Base. These methods should remove the need to interact with the grid field directly, and also allow to set and get values using the geographic coordinates (as opposed to the grid positions).","category":"page"},{"location":"man/overloads/#From-Base","page":"Overloads","title":"From Base","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"copy\ncollect\neltype\nsize\nstride\neachindex\nsimilar\nBase.sum\nBase.maximum\nBase.minimum\nBase.extrema\nBase.max\nBase.min\n+\n-\n*\n/\n==\nisequal","category":"page"},{"location":"man/overloads/#Base.copy","page":"Overloads","title":"Base.copy","text":"Base.copy(l::T) where {T <: SimpleSDMLayer}\n\nReturns a new copy of the layer, which has the same type.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.collect","page":"Overloads","title":"Base.collect","text":"Base.collect(l::T) where {T <: SimpleSDMLayer}\n\nReturns the non-nothing values of a layer.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.eltype","page":"Overloads","title":"Base.eltype","text":"Base.eltype(layer::SimpleSDMLayer{T}) where {T}\n\nReturns the type of the values stored in the grid, where the Nothing type is omitted.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.size","page":"Overloads","title":"Base.size","text":"Base.size(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the size of the grid.\n\n\n\n\n\nBase.size(layer::T, i...) where {T <: SimpleSDMLayer}\n\nReturns the size of the grid alongside a dimension.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.stride","page":"Overloads","title":"Base.stride","text":"Base.stride(layer::T; dims::Union{Nothing,Integer}=nothing) where {T <: SimpleSDMLayer}\n\nReturns the stride, i.e. half the length, of cell dimensions, possibly alongside a side of the grid. The first position is the length of the longitude cells, the second the latitude.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.eachindex","page":"Overloads","title":"Base.eachindex","text":"Base.eachindex(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the index of the grid.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.similar","page":"Overloads","title":"Base.similar","text":"Base.similar(layer::T, ::Type{TC}) where {TC <: Any, T <: SimpleSDMLayer}\n\nReturns a SimpleSDMResponse of the same dimensions as the original layer, with nothing in the same positions. The rest of the values are replaced by the output of zero(TC), which implies that there must be a way to get a zero for the type. If not, the same result can always be achieved through the use of copy, manual update, and convert.\n\n\n\n\n\nBase.similar(layer::T) where {T <: SimpleSDMLayer}\n\nReturns a SimpleSDMResponse of the same dimensions as the original layer, with nothing in the same positions. The rest of the values are replaced by the output of zero(element_type), which implies that there must be a way to get a zero for the type. If not, the same result can always be achieved through the use of copy, manual update, and convert.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.sum","page":"Overloads","title":"Base.sum","text":"Base.sum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies sum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.sum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies sum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.maximum","page":"Overloads","title":"Base.maximum","text":"Base.maximum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies maximum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.maximum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies maximum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.minimum","page":"Overloads","title":"Base.minimum","text":"Base.minimum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies minimum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.minimum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies minimum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.extrema","page":"Overloads","title":"Base.extrema","text":"Base.extrema(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies extrema (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.extrema(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies extrema (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.max","page":"Overloads","title":"Base.max","text":"Base.max(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies max (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that max is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.min","page":"Overloads","title":"Base.min","text":"Base.min(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies min (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that min is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:+","page":"Overloads","title":"Base.:+","text":"Base.+(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies + (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that + is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:-","page":"Overloads","title":"Base.:-","text":"Base.-(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies - (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that - is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:*","page":"Overloads","title":"Base.:*","text":"Base.*(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies * (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that * is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:/","page":"Overloads","title":"Base.:/","text":"Base./(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies / (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that / is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:==","page":"Overloads","title":"Base.:==","text":"==(layer1::SimpleSDMLayer, layer2::SimpleSDMLayer)\n\nTests whether two SimpleSDMLayer elements are equal. The layers are equal if  all their fields (grid, left, right, bottom, top) are equal, as  verified with == (e.g., layer1.grid == layer2.grid).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.isequal","page":"Overloads","title":"Base.isequal","text":"isequal(layer1::SimpleSDMLayer, layer2::SimpleSDMLayer)\n\nTests whether two SimpleSDMLayer elements are equal. The layers are equal if  all their fields (grid, left, right, bottom, top) are equal, as  verified with isequal (e.g., isequal(layer1.grid, layer2.grid)).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#From-Broadcast","page":"Overloads","title":"From Broadcast","text":"","category":"section"},{"location":"man/overloads/#From-Statistics","page":"Overloads","title":"From Statistics","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"Statistics.mean\nStatistics.median\nStatistics.std\nStatistics.quantile","category":"page"},{"location":"man/overloads/#Statistics.mean","page":"Overloads","title":"Statistics.mean","text":"Statistics.mean(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies mean (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.mean(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies mean (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.mean(layers::Array{T}) where {T <: SimpleSDMLayer}\n\nApplies mean (from Statistics) to the elements in corresponding positions from the different layers (similar to mean(a::Array{Matrix})) and returns the result as a new SimpleSDMResponse layer. Note that mean is only applied to the positions  without a nothing element and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.median","page":"Overloads","title":"Statistics.median","text":"Statistics.median(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies median (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.median(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies median (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.std","page":"Overloads","title":"Statistics.std","text":"Statistics.std(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies std (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.std(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies std (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.std(layers::Array{T}) where {T <: SimpleSDMLayer}\n\nApplies std (from Statistics) to the elements in corresponding positions from the different layers (similar to mean(a::Array{Matrix})) and returns the result as a new SimpleSDMResponse layer. Note that std is only applied to the positions  without a nothing element and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.quantile","page":"Overloads","title":"Statistics.quantile","text":"quantile(layer::T, p) where {T <: SimpleSDMLayer}\n\nReturns the quantiles of layer at p, using Statistics.quantile.\n\n\n\n\n\n","category":"function"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/geometry.jl\"","category":"page"},{"location":"examples/geometry/#Working-with-geometry-objects","page":"Geometry for clipping","title":"Working with geometry objects","text":"","category":"section"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"The SimpleSDMLayers package uses Points to represent coordinates, which allows to easily use GeometryBasics objects for masking. In this example, we will illustrate how we can get the values around a given point, and within a polygon. These functions all rely on mask to extract the values.","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"using SimpleSDMLayers\nusing GeometryBasics\nusing Plots\nusing JSON\n\nlayer = SimpleSDMPredictor(WorldClim, BioClim; resolution=5.0, left=-89., right=-70., top=27., bottom=15.)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"Let's have a look at the data, before applying any transformation:","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"plot(layer)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"We will now define a center of 5 degree of radius centered on La Habana","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"la_habana = Point(-82.38304, 23.13302)\narea = Circle(la_habana, 5.0)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"We can plot the background of the map, and add the clipped region:","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"plot(layer, c=:lightgrey, frame=:box)\nplot!(mask(area, layer), c=:turku)\nscatter!(la_habana, lab=\"\", c=:white, msw=2.0)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"This approach is useful if you want to mask according to a polygon. In this case, we will keep the values within a polygon representing Cuba. We grab data from Natural Earth Resources, that do not have the best resolution in terms of borders, but are sufficient for this illustration:","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"borders = download(\"https://raw.githubusercontent.com/AshKyd/geojson-regions/master/countries/50m/CUB.geojson\")\ncuba_data = JSON.parsefile(borders)\npolys = cuba_data[\"geometry\"][\"coordinates\"]\nCUBA = SimpleSDMLayers._format_polygon.(polys)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"This object is actually a multi-polygon, or an array of polygons. The mask function can handle this:","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"plot(layer, c=:lightgrey, frame=:box)\nplot!(mask(CUBA, layer), c=:turku)\nscatter!(la_habana, lab=\"\", c=:white, msw=2.0)","category":"page"},{"location":"examples/geometry/","page":"Geometry for clipping","title":"Geometry for clipping","text":"The delimitation of the area to crop is only as good as the underlying GeoJSON polygons, which in this case is missing some coastal areas. As a sidenote, the center of the grid cell is checked for being in the polygon (not any coordinate within the grid cell) - for this reason, coarser rasters (e.g. at 10 minutes resolution) may not respond perfectly well to masking in this way.","category":"page"},{"location":"man/io/#Reading-and-writing-files","page":"IO","title":"Reading and writing files","text":"","category":"section"},{"location":"man/io/","page":"IO","title":"IO","text":"SimpleSDMLayers.ascii\ngeotiff","category":"page"},{"location":"man/io/#SimpleSDMLayers.ascii","page":"IO","title":"SimpleSDMLayers.ascii","text":"ascii(file::AbstractString, datatype::Type{T}=Float64) where {T <: Number}\n\nReads the content of a grid file to a SimpleSDMPredictor, the type of which is given by the datatype argument.\n\n\n\n\n\nascii(layer::SimpleSDMPredictor{T}, file::AbstractString; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrites a layer to a grid file, with a given nodata value. The layer must store numbers.\n\n\n\n\n\nascii(layer::SimpleSDMResponse{T}, file::AbstractString; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrites a layer to a grid file, with a given nodata value. The layer must store numbers.\n\n\n\n\n\n","category":"function"},{"location":"man/io/#SimpleSDMLayers.geotiff","page":"IO","title":"SimpleSDMLayers.geotiff","text":"geotiff(::Type{LT}, file, bandnumber::Integer=1; left=nothing, right=nothing, bottom=nothing, top=nothing) where {LT <: SimpleSDMLayer}\n\nThe geotiff function reads a geotiff file, and returns it as a matrix of the correct type. The optional arguments left, right, bottom, and left are defining the bounding box to read from the file. This is particularly useful if you want to get a small subset from large files.\n\nThe first argument is the type of the SimpleSDMLayer to be returned.\n\n\n\n\n\ngeotiff(file::AbstractString, layer::SimpleSDMPredictor{T}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a single layer to a file, where the nodata field is set to an arbitrary value.\n\n\n\n\n\ngeotiff(file::AbstractString, layers::Vector{SimpleSDMPredictor{T}}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nStores a series of layers in a file, where every layer in a band. See geotiff for other options.\n\n\n\n\n\ngeotiff(file::AbstractString, layer::SimpleSDMResponse{T}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a single SimpleSDMResponse layer to a file.\n\n\n\n\n\ngeotiff(file::AbstractString, layers::Vector{SimpleSDMResponse{T}}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a vector of SimpleSDMResponse layers to bands in a file.\n\n\n\n\n\n","category":"function"},{"location":"man/indexing/#Indexing-interface","page":"Indexing","title":"Indexing interface","text":"","category":"section"},{"location":"man/indexing/","page":"Indexing","title":"Indexing","text":"In versions prior to 0.8, the indexing syntax (x[y]) had been a little bit abused to mean two different things: getting data out of a raster, and getting a raster out of a raster. Starting from 0.8, the indexing interface (i.e. anything relying on getindex and setindex!) is used to act on values. The resizing of rasters is now handled by the clip function.","category":"page"},{"location":"man/indexing/#Getting-values-out-of-a-raster","page":"Indexing","title":"Getting values out of a raster","text":"","category":"section"},{"location":"man/indexing/","page":"Indexing","title":"Indexing","text":"getindex","category":"page"},{"location":"man/indexing/#Base.getindex","page":"Indexing","title":"Base.getindex","text":"Base.getindex(layer::T, i::CartesianIndex{2}) where {T <: SimpleSDMLayer}\n\nReturns the value stored at a given cartesian index.\n\n\n\n\n\nBase.getindex(layer::T, i::Integer) where {T <: SimpleSDMLayer}\n\nReturns the value stored at a linear index (a good candidate for deprecation as we have a better iteration interface now).\n\n\n\n\n\nBase.getindex(layer::T, i::Integer, j::Integer) where {T <: SimpleSDMLayer}\n\nStandard abstract array accession, where the dimensions follow the dimensions of the underlying grid.\n\n\n\n\n\nBase.getindex(layer::T, i::Array{CartesianIndex{2}}) where {T <: SimpleSDMLayer}\n\nReturns an array of values based on an array of cartesian indices - this can be a vector or a matrix, and the elements can be in any order. This will not return a raster.\n\n\n\n\n\nBase.getindex(layer::T, longitude::AbstractFloat, latitude::AbstractFloat) where {T <: SimpleSDMLayer}\n\nReturns a value by longitude and latitude.\n\n\n\n\n\nBase.getindex(layer::T, c::Point) where {T <: SimpleSDMLayer}\n\nAccess a value through a Point (from GeometryBasics), which has the longitude first and the latitude last – this follows the GeoJSON convention.\n\n\n\n\n\nBase.getindex(layer::T, c::Array{<:Point}) where {T <: SimpleSDMLayer}\n\nAccess a value through an array of Point (from GeometryBasics), which has the longitude first and the latitude last. The array can be in any order, so this method will not return a raster.\n\n\n\n\n\nBase.getindex(::T, ::Nothing) where {T <: SimpleSDMLayer}\n\nIf the user requests a point that is out of bounds, its cartesian coordinate will be matched to nothing, and then we return nothing.\n\n\n\n\n\nBase.getindex(p::T, occurrence::GBIF.GBIFRecord) where {T <: SimpleSDMLayer}\n\nExtracts the value of a layer at a given position for a GBIFRecord. If the GBIFRecord has no latitude or longitude, this will return nothing.\n\n\n\n\n\nBase.getindex(layer::T, records::GBIF.GBIFRecords) where {T <: SimpleSDMLayer}\n\nReturns the values of a layer at all occurrences in a GBIFRecords collection.\n\n\n\n\n\nBase.getindex(layer::T, records::Vector{GBIF.GBIFRecord}) where {T <: SimpleSDMLayer}\n\nReturns the values of a layer at all occurrences in a GBIFRecord array.\n\n\n\n\n\n","category":"function"},{"location":"man/indexing/#Writing-values-in-a-raster","page":"Indexing","title":"Writing values in a raster","text":"","category":"section"},{"location":"man/indexing/","page":"Indexing","title":"Indexing","text":"setindex!","category":"page"},{"location":"man/indexing/#Base.setindex!","page":"Indexing","title":"Base.setindex!","text":"Base.setindex!(layer::T, v, record::GBIFRecord) where {T <: SimpleSDMResponse}\n\nChanges the values of the cell including the point at the requested latitude and longitude. Be careful, this function will not update a cell that has nothing.\n\n\n\n\n\n","category":"function"},{"location":"man/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Layers are represented by a grid, storing the content of cells in a Matrix, and a bounding box indicated by the floating point coordinates of its limits.","category":"page"},{"location":"man/types/#Implemented-types","page":"Types","title":"Implemented types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"SimpleSDMLayer\nSimpleSDMResponse\nSimpleSDMPredictor","category":"page"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMLayer","page":"Types","title":"SimpleSDMLayers.SimpleSDMLayer","text":"All types in the package are part of the abstract type SimpleSDMLayer. A SimpleSDMLayer has five core fields: grid is a matrix storing the cells, and left, right, bottom and top are floating point numbers specifying the bounding box.\n\nIt is assumed that the missing values will be represented as nothing, so internally the matrix will have type Union{T, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMResponse","page":"Types","title":"SimpleSDMLayers.SimpleSDMResponse","text":"A response is a SimpleSDMLayer that is mutable, and is the usual type to store analysis outputs. You can transform a response into a predictor using convert.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMPredictor","page":"Types","title":"SimpleSDMLayers.SimpleSDMPredictor","text":"A predictor is a SimpleSDMLayer that is immutable, and so does not have methods for setindex!, etc. It is a safe way to store values that should not be modified by the analysis. Note that if you are in a bind, the values of the grid field are not immutable, but don't tell anyone we told you. The correct way of handling predictors you need to modify would be to use convert methods.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#Getting-the-coordinates","page":"Types","title":"Getting the coordinates","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"latitudes\nlongitudes\nboundingbox","category":"page"},{"location":"man/types/#SimpleSDMLayers.latitudes","page":"Types","title":"SimpleSDMLayers.latitudes","text":"latitudes(layer::T) where {T <: SimpleSDMLayer}\n\nReturns an iterator with the latitudes of the SDM layer passed as its argument. This returns the latitude at the center of each cell in the grid.\n\n\n\n\n\nlatitudes(records::GBIFRecords)\n\nReturns the non-missing latitudes.\n\n\n\n\n\n","category":"function"},{"location":"man/types/#SimpleSDMLayers.longitudes","page":"Types","title":"SimpleSDMLayers.longitudes","text":"longitudes(layer::T) where {T <: SimpleSDMLayer}\n\nReturns an iterator with the longitudes of the SDM layer passed as its argument. This returns the longitudes at the center of each cell in the grid.\n\n\n\n\n\nlongitudes(records::GBIFRecords)\n\nReturns the non-missing longitudes.\n\n\n\n\n\n","category":"function"},{"location":"man/types/#SimpleSDMLayers.boundingbox","page":"Types","title":"SimpleSDMLayers.boundingbox","text":"boundingbox(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the bounding coordinates of a layer as NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/types/#Type-conversion","page":"Types","title":"Type conversion","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"convert","category":"page"},{"location":"man/types/#Base.convert","page":"Types","title":"Base.convert","text":"Base.convert(::Type{SimpleSDMResponse}, layer::T) where {T <: SimpleSDMPredictor}\n\nReturns a response with the same grid and bounding box as the predictor.\n\n\n\n\n\nBase.convert(::Type{SimpleSDMPredictor}, layer::T) where {T <: SimpleSDMResponse}\n\nReturns a predictor with the same grid and bounding box as the response.\n\n\n\n\n\nBase.convert(::Type{T}, layer::TL) where {T <: Number, TL <: SimpleSDMLayer}\n\nReturns a copy of the layer with the same type (response or predictor), but the element type has been changed to T (which must be a number). This function is extremely useful (required, in fact) for plotting, as the nothing values are changed to NaN in the heatmaps.\n\n\n\n\n\nBase.convert(::Type{Matrix}, layer::T) where {T <: SimpleSDMLayer}\n\nReturns the grid as an array.\n\n\n\n\n\n","category":"function"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/bioclim.jl\"","category":"page"},{"location":"sdm/bioclim/#Building-the-BIOCLIM-model","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"","category":"section"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"Justification for this use case: SImpleSDMLayers can be used as a platform to build your own species distribution models. In this example, which assumes that you have read the vignettes on GBIF integration and variable selection through VIF, we will build our own version of the BIOCLIM model, and apply it to the distribution of Hypomyces lactifluorum in North America.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"using SimpleSDMLayers\nusing GBIF\nusing Plots\nusing GLM\nusing StatsBase\nusing Statistics\nusing GeometryBasics","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"BIOCLIM is a very simple model, which only requires presence information. The first step is therefore to get occurrences of Hypomyces lactifluorum in North America. Because the data in GBIF is only as good as the original data source, sometimes searching by continent gives fewer results than searching by country.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"observations = occurrences(\n    GBIF.taxon(\"Hypomyces lactifluorum\"; strict=true),\n    \"hasCoordinate\" => \"true\",\n    \"country\" => \"CA\",\n    \"country\" => \"US\",\n    \"limit\" => 300,\n)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"We will now page through additional results (300 at a time).","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"while length(observations) < size(observations)\n    occurrences!(observations)\nend","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"At this point, we could read the whole predictor variables directly, and then clip them. This would be fairly wasteful, as we need a small area. For this reason, we will calculate the bounding box first, and then use it to only read the section we want.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"left, right = extrema(longitudes(observations)) .+ (-5, 5)\nbottom, top = extrema(latitudes(observations)) .+ (-5, 5)\nboundaries = (left=left, right=right, bottom=bottom, top=top)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"With this information in hand, we can start getting our variables. In this example, we will take all of the BioClim data from WorldClim, at the 10 arc minute resolution, and add the elevation layer. Note that using the bounding box coordinates when calling the layers is much faster than clipping after the fact (assuming that you already have the files downloaded).","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"predictors =\n    convert.(\n        Float32, SimpleSDMPredictor(WorldClim, BioClim, 1:19; resolution=10.0, boundaries...)\n    );\nnothing #hide","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"We will add the elevation to the stack of variables we use – we need to convert everything to Float32 layers, because elevation is originally an Int16 one and a number of operations we will make will require floating points","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"push!(\n    predictors,\n    convert(\n        Float32, SimpleSDMPredictor(WorldClim, Elevation; resolution=10.0, boundaries...)\n    ),\n);\nnothing #hide","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"It is not a bad idea to plot all of the predictors:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"plot(plot.(predictors, grid=:none, axes=false, frame=:none, leg=false, c=:imola)...)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"Clearly, some of them show strong autocorrelation; we will therefore re-use our VIF code to select a subset that has uncorrelated variables.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"function vif(model)\n    R² = r2(model)\n    return 1 / (1-R²)\nend\n\nfunction stepwisevif(\n    layers::Vector{T}, selection=collect(1:length(layers)), threshold::Float64=5.0\n) where {T<:SimpleSDMLayer}\n    x = hcat([layer[keys(layer)] for layer in layers[selection]]...)\n    X = (x .- mean(x; dims=1)) ./ std(x; dims=1)\n    vifs = zeros(Float64, length(selection))\n    for i in eachindex(selection)\n        vifs[i] = vif(lm(X[:, setdiff(eachindex(selection), i)], X[:, i]))\n    end\n    all(vifs .<= threshold) && return selection\n    drop = last(findmax(vifs))\n    popat!(selection, drop)\n    @info \"Variables remaining: $(selection)\"\n    return stepwisevif(layers, selection, threshold)\nend","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"We will apply this function with the default parameters:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"layers_to_keep = stepwisevif(predictors)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"When this is done, we can plot  the layers again to check that they are all more or less unique:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"plot(\n    plot.(\n        predictors[layers_to_keep], grid=:none, axes=false, frame=:none, leg=false, c=:imola\n    )...,\n)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"The point of BIOCLIM (the model, not the dataset) is that the score assigned to a pixel is maximal if this pixel is the median value for a given variable. Therefore, we need to measure the cumulative density function for every pixel in every variable, and transform it with:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"_pixel_score(x) = 2.0(x > 0.5 ? 1.0 - x : x);\nnothing #hide","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"The actual model generation is fairly straightforward, as we will need to get the values of the layers in the cells occupied by an observation. Because sampling bias is very real, we will grid the observations by transforming them into a boolean layer:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"presences = mask(predictors[1], observations, Bool)\nplot(convert(Float32, presences); c=cgrad([:lightgrey, :black]), leg=false)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"This step is very important so as not to bias the estimation of quantiles, which overcounting observations within the same cell would do. We can now define the model:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"function SDM(predictor::T1, observations::T2) where {T1<:SimpleSDMLayer,T2<:SimpleSDMLayer}\n    _tmp = mask(observations, predictor)\n    qf = ecdf(convert(Vector{Float32}, _tmp[keys(_tmp)])) # We only want the observed values\n    return (_pixel_score ∘ qf)\nend","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"Note that we use the ∘ (\\circ) operator to chain the quantile estimation and the pixel scoring, which requires Julia 1.4. This function returns a model, i.e. a function that we can broadcast to a given layer, which might not be the same one we used for the training.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"The next step in BIOCLIM is to get the minimum suitability across all layers for every pixel. Because we have a min method defined for a pair of layers, we can call minimum on an array of layers:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"function SDM(predictors::Vector{T}, models) where {T<:SimpleSDMLayer}\n    @assert length(models) == length(predictors)\n    return minimum([broadcast(models[i], predictors[i]) for i in 1:length(predictors)])\nend","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"The advantage of this approach is that we can call the SDM method for prediction on a smaller layer, or a different layer. This can allow us to do thing like stitching layers together with hcat and vcat to use multi-threading, or use a different resolution for the prediction than we did for the training.","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"models = [SDM(predictor, presences) for predictor in predictors];\nnothing #hide","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"We now get the prediction:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"prediction = SDM(predictors, models)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"It's not a bad idea to look at this prediction, to get a sense of where the hotspots of presence would be:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"plot(prediction; c=:bamako, frame=:box)\nxaxis!(\"Longitude\")\nyaxis!(\"Latitude\")","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"Just because we may want to visualize this result in a transformed way, i.e. by looking at the quantiles of suitability, we can call the rescale function:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"prediction_quantile = rescale(prediction, collect(0.0:0.005:1.0))","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"As this map now represents the quantiles of suitability, we may want to remove the lower 5%. For this, we need to create a boolean mask, which we can do by broadcasting a conditional:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"cutoff = broadcast(x -> x > 0.05, prediction_quantile)","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"The raw prediction, minus the 5% bottom quantiles, can the be plotted:","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"plot(prediction; frame=:box, c=:lightgrey)\nplot!(mask(cutoff, prediction); c=:bamako)\nxaxis!(\"Longitude\")\nyaxis!(\"Latitude\")","category":"page"},{"location":"sdm/bioclim/","page":"Building the BIOCLIM model","title":"Building the BIOCLIM model","text":"And there it is! A simple way to write the BIOCLIM model by building on the integration between SimpleSDMLayers and GBIF. BIOCLIM has a tendency to underfit the distribution quite a bit - in fact, the range returned here is larger than what other methods (like BRT) would return. The next vignettes in this section will be focused on using additional functionalities of SimpleSDMLayers until we are able to make a better model for this species.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/future.jl\"","category":"page"},{"location":"sdm/future/#Future-climate-data","page":"Dealing with future data","title":"Future climate data","text":"","category":"section"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"using SimpleSDMLayers\nusing Plots\nusing Statistics","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"Justification for this use case: we will often want to forecast the range of species under a variety of climate change scenarios. For this reason, SimpleSDMLayers offers access to CMIP5 and CMIP6 scenarios or models, to be used in these situations.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"For some data providers and datasets, SimpleSDMLayers offers access to future climate data. Future climates are usually specified by a model, and a scenario. For example, WorldClim 2.1 offers the full suite of BioClim variable under four SSPs and a number of CMIP6 models.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"We can use this to look at, for example, the temperature difference between the current and future climate. To illustrate this, we will do a simple example where we contrast the \"historical\" climate (i.e. what is assumed to be the current data) to the projected  data under SSP585 in the 2041-2060 period.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"We will start by getting the contemporary data:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"boundaries = (left=-169.0, right=-50.0, bottom=24.0, top=71.0)\nbaseline = SimpleSDMPredictor(WorldClim, BioClim, 1; boundaries...)\ncontour(baseline; c=:cork, frame=:box, fill=true, clim=(-30, 30), levels=6)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"To get a future dataset, we need to specify the model - models are combinations of a CMIP version, and either a RCP or SSP:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"instances(CMIP6)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"And we need to check the names of the SSP we want to use:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"instances(SharedSocioeconomicPathway)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"We can now get our future temperature layer (and plot it), for a valid model/scenario combination, and plot it. We will pick an extreme scenario at a long (yet frighteningly short) time in the future. In order to facilitate the comparison with the previous plot, we will re-use the same color limites, where blue is negatuve temperatures.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"future = SimpleSDMPredictor(WorldClim, BioClim, CanESM5, SSP585, 1; year=\"2061-2080\", boundaries...)\ncontour(future; c=:cork, frame=:box, fill=true, clim=(-30, 30), levels=6)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"Note that the call to get the future data is almost the same as the historical one - the exception is the addition of the model and scenario, and the specification of the years. With this layer, we can now measure the difference in mean annual temperature, because layers can be substracted. Note that we are switching the scale: the difference between the two layers here is always positive.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"plot(future - baseline, frame=:box, c=:lajolla)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"We might actually be interested in averaging multiple models. Because we know the variety of models worldclim has (instances(CMIP6)), we can do this fairly easily. One of the model has no predictions for SSP585 (which we would learn in the form of an error message), so we will filter it out directly.","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"ensemble = [\n    SimpleSDMPredictor(\n        WorldClim, BioClim, model, SSP585, 1;\n        year=\"2061-2080\", boundaries...\n    ) for model in instances(CMIP6) if model != GFDLESM4\n];\nnothing #hide","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"We can create a layer of differences from each scenario to the baseline:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"differences = [component - baseline for component in ensemble];\nnothing #hide","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"This can be plotted as a grid of differences, using the same colorscale as in the previous plot:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"plot(plot.(differences, c=:lajolla, grid=:none, axes=false, frame=:none, leg=false)...)","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"Finally, we can plot the average of the expected conditions under the scenario we considered:","category":"page"},{"location":"sdm/future/","page":"Dealing with future data","title":"Dealing with future data","text":"contour(mosaic(mean, ensemble); c=:cork, frame=:box, fill=true, clim=(-30, 30), levels=6)","category":"page"},{"location":"man/operations/#Other-operations","page":"Other operations","title":"Other operations","text":"","category":"section"},{"location":"man/operations/","page":"Other operations","title":"Other operations","text":"coarsen\nslidingwindow\nmask","category":"page"},{"location":"man/operations/#SimpleSDMLayers.coarsen","page":"Other operations","title":"SimpleSDMLayers.coarsen","text":"coarsen(L::LT, f::FT, d::Tuple{IT,IT}) where {LT <: SimpleSDMLayer, FT <: Function, IT <: Integer}\n\nThis function will aggregate a layer by merging cells. The function f passed as its second argument is expected to take an array as input, and return a single value of any type (but it is sort of a social contract here that this will be a number of some sort, and if it is not, that you really know what you're doing).\n\nThe size of the cells to aggregate is given by the tuple, so that (2,2) will make groups of two cells vertically and two cells horizontally, for a total of four cells. By default, the cells containing nothing will be ignored, so that f is only applied to non-nothing values.\n\nIn cases where the number of cells to aggregate is not matching with the size of the grid, and ArgumentError will be thrown. Note that there is no expectation that the two values in d will be the same.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.slidingwindow","page":"Other operations","title":"SimpleSDMLayers.slidingwindow","text":"slidingwindow(L::LT, f::FT, d::IT) where {LT <: SimpleSDMLayer, FT <: Function, IT <: Number}\n\nThis function will replace the value at any cell by applying the function f to the array of cells values that are within a distance d (in kilometers) from the focal cell. This is, for example, useful to use an average to smooth out the layers. The distance is estimated using the haversine distance, assuming that the radius of the Earth is 6371.0 km. This means that the size of the window will vary a little bit across latitudes, but this is far better than using a number of cells, which would have dramatic consequences near the poles.\n\nIt always returns a SimpleSDMResponse, and the cells containing nothing will also not contain a value in the output. This is different from the behavior of coarsen, which tends to expand the area of the layer in which we have data.\n\nThis function is currently relatively slow. Performance improvements will arrive at some point.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.mask","page":"Other operations","title":"SimpleSDMLayers.mask","text":"mask(l1::T1, l2::T2) where {T1 <: SimpleSDMLayer, T2 <: SimpleSDMLayer}\n\nReturns a copy of the second layer in which the positions for which the first layer is zero (of the appropriate type) or nothing are set to nothing. This is mostly useful in cases where you have a Bool layer.\n\n\n\n\n\nmask(layer::SimpleSDMLayer, records::GBIF.GBIFRecords, element_type::Type=Bool)\n\nCreate a new layer storing information about the presence of occurrences in the cells, either counting (numeric types) or presence-absence-ing (boolean types) them.\n\n\n\n\n\n","category":"function"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/pca.jl\"","category":"page"},{"location":"examples/pca/#MultivariateStats.jl-integration","page":"Multivariate statistics","title":"MultivariateStats.jl integration","text":"","category":"section"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"In this example we explore how you can use MultivariateStats.jl with SimpleSDMLayers to perform principal-component-analysis (PCA) to reduce the dimensionality of a set of SDMLayers, or to remove the covariance between layers via data whitening.","category":"page"},{"location":"examples/pca/#Principal-component-analysis-of-many-SDMLayers","page":"Multivariate statistics","title":"Principal-component analysis of many SDMLayers","text":"","category":"section"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"using SimpleSDMLayers\nusing MultivariateStats\nusing Plots","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"The SimpleSDMLayers enables integration with MultivariateStats.jl In this example, we will show how this can work.","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"boundaries =(left = -164.022167, right = -55.250858, bottom = 23.547132, top = 72.105833)\nlayers = convert.(\n    Float32,\n    SimpleSDMPredictor(WorldClim, BioClim, 1:19; boundaries...)\n)","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"fit pca and project to a new set of layers","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"pca = fit(PCA, layers)\nnewlayers = transform(pca, layers)","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"plot them","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"pcaplots = plot.(newlayers)\nplot(pcaplots...)","category":"page"},{"location":"examples/pca/#Remove-correlation-between-layers-(Whitening)","page":"Multivariate statistics","title":"Remove correlation between layers (Whitening)","text":"","category":"section"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"Have to start with two layers that are reasonably correlated.","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"wlayers = convert.(\n    Float32,\n    SimpleSDMPredictor(WorldClim, BioClim, 1:2; boundaries...)\n)\nplot(plot.(wlayers)...)","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"Now we call methods just as in MultivariateStats","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"w = fit(Whitening, wlayers)\nnewlayers = transform(w, wlayers)","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"and plot the layers without covar","category":"page"},{"location":"examples/pca/","page":"Multivariate statistics","title":"Multivariate statistics","text":"plot(plot.(newlayers)...)","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/vif.jl\"","category":"page"},{"location":"sdm/vif/#Variable-selection-with-the-VIF","page":"Variable selection (VIF)","title":"Variable selection with the VIF","text":"","category":"section"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"using SimpleSDMLayers\nusing GLM\nusing Statistics","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"Justification for this use case: a lot of predictive variables are auto-correlated, and therefore one might argue that maybe, we may eventually build better models by removing some of them. This is generally refered to as variable selection, and sharing one's opinion on this is the fastest way to start a brawl at any gathering of ecologists.","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"We will illustrate variable selection with the Variance Inflation Factor using the bioclim data from the region in which Hypomyces lactifluorum is found.","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"layers = SimpleSDMPredictor(\n    WorldClim, BioClim, 1:19; left=-169.0, right=-50.0, bottom=24.0, top=71.0\n);\nnothing #hide","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"We will first gather everything in a matrix:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"x = hcat([layer[keys(layer)] for layer in layers]...);\nsize(x)","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"Because of the spread of some values, we will center and reduce this matrix to give every variable a mean of 0 and unit variance:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"X = (x .- mean(x; dims=1)) ./ std(x; dims=1)\nround.(Int, mean(X; dims=1))","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"The VIF is simply measured as 1/(1-R²) by regressing every variable against all others. Let's have an illustration with the first predictor:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"function vif(model)\n    R² = r2(model)\n    return 1 / (1 - R²)\nend\n\nvif(lm(X[:, 2:end], X[:, 1]))","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"The generally agreed threshold for a good VIF is 2, or 5, or 10 (so both \"generally\" and \"agreed\" are overstatements here), and as this one is higher, it suggests that we may not need all of these data. It is also entirely possible to have an infinite VIF, in case two variables are perfectly correlated (this happens a fair amount with bioclim, in fact).","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"For this reason, we will go through an iterative process to get rid of variables one by one until the largest VIF is no larger than some threshold. Specifically, we get rid of the variable with the largest VIF first. Let's try this with the full sample:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"vifs = zeros(Float64, length(layers))\nfor i in eachindex(layers)\n    vifs[i] = vif(lm(X[:, setdiff(eachindex(selection), i)], X[:, i]))\nend\nfindmax(vifs)","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"This result suggests that this variable, because it has the highest VIF (and one that is above our threshold), should be dropped. Repeating the process is a good use case for a recursive function:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"function stepwisevif(\n    layers::Vector{T}, selection=collect(1:length(layers)), threshold::Float64=5.0\n) where {T<:SimpleSDMLayer}\n    x = hcat([layer[keys(layer)] for layer in layers[selection]]...)\n    X = (x .- mean(x; dims=1)) ./ std(x; dims=1)\n    vifs = zeros(Float64, length(selection))\n    for i in eachindex(selection)\n        vifs[i] = vif(lm(X[:, setdiff(eachindex(selection), i)], X[:, i]))\n    end\n    all(vifs .<= threshold) && return selection\n    drop = last(findmax(vifs))\n    popat!(selection, drop)\n    @info \"Variables remaining: $(selection)\"\n    return stepwisevif(layers, selection, threshold)\nend","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"This function will operate on a collection of layers, and starting from a selection (of indices), iterate until a subset satisfying max(VIF) < threshold is found. We can run this function on our entire dataset:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"selected_variables_id = stepwisevif(layers)","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"Which variables are these?","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"layernames(WorldClim, BioClim)[selected_variables_id]","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"Finally, we can select the variables this process recommends:","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"layers[selected_variables_id]","category":"page"},{"location":"sdm/vif/","page":"Variable selection (VIF)","title":"Variable selection (VIF)","text":"Before we move on – variable selection, especially stepwise, is not necessarilly a good practice. Alternatives are model selection, dimensionality reduction using e.g. PCA, or other methods to remove the problematic covariance structure in the data. In Julia, a lot of this can be done using the MultivariateStats package. This can be an interesting exercise: rather than relying on VIF, what would the dimensionsality of the results look like with a PCA cutoff at 99% of explained variance?","category":"page"},{"location":"man/data/#Datasets","page":"Data access","title":"Datasets","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"The package offers access to bioclimatic and other datasets - they are downloaded, saved to the disk, and then read locally. Please note that some of them require a lot of memory, so make sure your machine can handle them.","category":"page"},{"location":"man/data/","page":"Data access","title":"Data access","text":"By default, the layers are stored in the assets subfolder of the current project. This being said, the prefered solution is to define a SDMLAYERS_PATH environment variable pointing to a specific path, where the layers will live. This will ensure that they are re-used between projects.","category":"page"},{"location":"man/data/","page":"Data access","title":"Data access","text":"All layers are returned as SimpleSDMPredictor, and therefore constructed by calling the SimpleSDMPredictor function on a LayerProvider and a LayerDataset, possibly with a future climate model and scenario. In all cases, the method accepts either a single layer, or an array of layers.","category":"page"},{"location":"man/data/","page":"Data access","title":"Data access","text":"Data provider Dataset Layers Future models Future scenarios\nEarthEnv Landcover 12  \nEarthEnv HabitatHeterogeneity 14  \nWorldClim BioClim 19 CMIP6 SharedSocioeconomicPathway\nWorldClim Elevation 1 Elevation \nCHELSA BioClim 12 CMIP5, CMIP6 RepresentativeConcentrationPathway, SharedSocioeconomicPathway","category":"page"},{"location":"man/data/#Providers-and-datasets","page":"Data access","title":"Providers and datasets","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"The layernames method (inputs are a provider and a dataset) will return a tuple with the name of the layers.","category":"page"},{"location":"man/data/#Data-providers","page":"Data access","title":"Data providers","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"SimpleSDMLayers.LayerProvider","category":"page"},{"location":"man/data/#SimpleSDMLayers.LayerProvider","page":"Data access","title":"SimpleSDMLayers.LayerProvider","text":"LayerProvider\n\nA LayerProvider is an abstract type used to dispatch the correct call of SimpleSDMPredictor to a specific dataset. A dataset is specified by a LayerProvider and a LayerDataset, as well as optionally one or multiple layers, and future climate information, resolution, or dates.\n\n\n\n\n\n","category":"type"},{"location":"man/data/","page":"Data access","title":"Data access","text":"WorldClim\nCHELSA\nEarthEnv","category":"page"},{"location":"man/data/#SimpleSDMLayers.WorldClim","page":"Data access","title":"SimpleSDMLayers.WorldClim","text":"WorldClim\n\nWorldClim offers bioclimatic data both historical and future, under CMIP6 scenarios.\n\nThis provider currently offers BioClim data, both historical and future under CMIP6, and the Elevation raster.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.CHELSA","page":"Data access","title":"SimpleSDMLayers.CHELSA","text":"CHELSA\n\nCHELSA offers high resolution climatologies. This provider currently offers BioClim data, both historical and future under CMIP5 and CMIP6.\n\nNote that CHELSA offers a subset of all possible CMIP6 combinations, which is supposed to be the most informative.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.EarthEnv","page":"Data access","title":"SimpleSDMLayers.EarthEnv","text":"EarthEnv\n\nData from the EarthEnv project, all released under a CC-BY-NC license to Tuanmu & Jetz. This provider currently offers LandCover and HabitatHeterogeneity rasters.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#Datasets-2","page":"Data access","title":"Datasets","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"SimpleSDMLayers.LayerDataset","category":"page"},{"location":"man/data/#SimpleSDMLayers.LayerDataset","page":"Data access","title":"SimpleSDMLayers.LayerDataset","text":"LayerDataset\n\nA LayerDataset is a specific set of rasters provided by a LayerProvider. For a number of dataset types that are very broad (LandCover, HabitatHeterogeneity), the precise mapping of layers is documented in their SimpleSDMPredictor method.\n\n\n\n\n\n","category":"type"},{"location":"man/data/","page":"Data access","title":"Data access","text":"BioClim\nLandCover\nHabitatHeterogeneity\nElevation","category":"page"},{"location":"man/data/#SimpleSDMLayers.BioClim","page":"Data access","title":"SimpleSDMLayers.BioClim","text":"BioClim\n\nA list of 19 bioclimatic variables derived from the monthly temperature and precipitation data. This dataset is provided by WorldClim and CHELSA, both of which offer future versions under CMIP5 and CMIP6 models.\n\nVariable Description\n1 Annual Mean Temperature\n2 Mean Diurnal Range (Mean of monthly (max temp - min temp))\n3 Isothermality (BIO2/BIO7) (* 100)\n4 Temperature Seasonality (standard deviation *100)\n5 Max Temperature of Warmest Month\n6 Min Temperature of Coldest Month\n7 Temperature Annual Range (BIO5-BIO6)\n8 Mean Temperature of Wettest Quarter\n9 Mean Temperature of Driest Quarter\n10 Mean Temperature of Warmest Quarter\n11 Mean Temperature of Coldest Quarter\n12 Annual Precipitation\n13 Precipitation of Wettest Month\n14 Precipitation of Driest Month\n15 Precipitation Seasonality (Coefficient of Variation)\n16 Precipitation of Wettest Quarter\n17 Precipitation of Driest Quarter\n18 Precipitation of Warmest Quarter\n19 Precipitation of Coldest Quarter\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.LandCover","page":"Data access","title":"SimpleSDMLayers.LandCover","text":"LandCover\n\nInformation on land cover, currently only provided by EarthEnv.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.HabitatHeterogeneity","page":"Data access","title":"SimpleSDMLayers.HabitatHeterogeneity","text":"HabitatHeterogeneity\n\nInformation on habitat heterogeneity, currently only provided by EarthEnv.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.Elevation","page":"Data access","title":"SimpleSDMLayers.Elevation","text":"Elevation\n\nGeneral type for a DEM, currently available through WorldClim\n\n\n\n\n\n","category":"type"},{"location":"man/data/#Future-data","page":"Data access","title":"Future data","text":"","category":"section"},{"location":"man/data/#CMIP5","page":"Data access","title":"CMIP5","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"CMIP5\nRepresentativeConcentrationPathway","category":"page"},{"location":"man/data/#SimpleSDMLayers.CMIP5","page":"Data access","title":"SimpleSDMLayers.CMIP5","text":"CMIP5\n\nEnumeration of the models from CMIP5, which can be listed with instances(CMIP5).\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.RepresentativeConcentrationPathway","page":"Data access","title":"SimpleSDMLayers.RepresentativeConcentrationPathway","text":"RepresentativeConcentrationPathway\n\nEnumeration of the four RCPs, which can be listed with instances(RepresentativeConcentrationPathway). These are meant to be used with CMIP5 models.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#CMIP6","page":"Data access","title":"CMIP6","text":"","category":"section"},{"location":"man/data/","page":"Data access","title":"Data access","text":"CIMP6\nSharedSocioeconomicPathway","category":"page"},{"location":"man/data/#SimpleSDMLayers.SharedSocioeconomicPathway","page":"Data access","title":"SimpleSDMLayers.SharedSocioeconomicPathway","text":"SharedSocioeconomicPathway\n\nEnumeration of the four SSPs, which can be listed with instances(SharedSocioeconomicPathway). These are meant to be used with CMIP6 models.\n\n\n\n\n\n","category":"type"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/elevation.jl\"","category":"page"},{"location":"examples/elevation/#Basics:-elevation-data","page":"Introduction: elevation data","title":"Basics: elevation data","text":"","category":"section"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"In this example, we will look at elevation data from the worldclim 2 data, crop it for Western Europe, and then change the resolution to aggregate the data. The first step is to get the worldclim layer for elevation:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"using SimpleSDMLayers\nusing StatsPlots\nimport Statistics","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"elevation = convert(Float32, SimpleSDMPredictor(WorldClim, Elevation))","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"Thanks to the integration with Plots and StatsPlots, we can very rapidly visualize these data:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"heatmap(elevation, c=:cividis, frame=:box)\nxaxis!(\"Longitude\")\nyaxis!(\"Latitude\")","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"Let's also have a look at the density while we're at it:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"density(elevation, frame=:zerolines, c=:grey, fill=(0, :grey, 0.2), leg=false)\nxaxis!(\"Elevation\")","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"The next step is to clip the data to the region of interest. This requires a the coordinates of the bounding box as two tuples (for longitude and latitude) – we can also make a quick heatmap to see what the region looks like:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"elevation_europe = clip(elevation; left=-11.0, right=31.5, bottom=29.0, top=71.5)","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"heatmap(elevation_europe, c=:cividis, aspectratio=1, frame=:box)","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"The next step will be to coarsen these data, which requires to give the number of cells to merge alongside each dimension. This number of cells must be a divider of the grid size, which we can view with:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"size(elevation_europe)","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"In an ideal world, we could want to find a number of cells that is the same both for latitude and longitude, and one approach is to finagle our way into a correct grid by changing the clipping region.","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"In this case, we will use a coarsening scale of (5,5), which gives us a total of 25 cells in the aggregated result. Our aggregation function will be mean (so we report the average elevation across these cells):","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"elevation_europe_coarse = coarsen(elevation_europe, Statistics.mean, (5, 5))","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"Once again, we can plot these data:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"heatmap(elevation_europe_coarse, aspectratio=1, c=:cividis, frame=:box)","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"Finally, we can compare our different clipping and approximations to the overall dataset:","category":"page"},{"location":"examples/elevation/","page":"Introduction: elevation data","title":"Introduction: elevation data","text":"density(elevation, frame=:zerolines, c=:grey, fill=(0, :grey, 0.5), lab=\"\")\ndensity!(elevation_europe, c=:black, lab=\"Raw data\")\ndensity!(elevation_europe_coarse, c=:darkgrey, lab=\"Average\")\nxaxis!(\"Elevation\")","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/multivariate.jl\"","category":"page"},{"location":"examples/multivariate/#Multivariate-maps","page":"Multivariate mapping","title":"Multivariate maps","text":"","category":"section"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"using SimpleSDMLayers\nusing StatsPlots\nusing StatsPlots.PlotMeasures\nusing Statistics","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"Justification for this use case: We can show more than one (specifically, two or three) variables on a single map, using a bivariate or trivariate color scale. In order to illustrate these mappings, we will look at the joint distribution of three measures: eveness of land use, terrain roughness, and proportion of urbanized land.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"boundaries = (left=-12.0, right=30.0, bottom=36.0, top=72.0)\nlayer1 = convert(\n    Float16,\n    SimpleSDMPredictor(EarthEnv, HabitatHeterogeneity, 2; resolution=5, boundaries...),\n)\nlayer2 = convert(\n    Float16, SimpleSDMPredictor(EarthEnv, Topography, 7; resolution=5, boundaries...)\n)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"The landcover data are finer than the other layers, so we will coarsen them. Because of rounding issues, the left and right cordinates need to be rounded.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"layer3 = coarsen(\n    convert(Float16, SimpleSDMPredictor(EarthEnv, LandCover, 9; boundaries...)),\n    mean,\n    (5, 5),\n)\nlayer3.left = round(layer3.left; digits=0)\nlayer3.right = round(layer3.right; digits=0)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"We finally mask everything according to the first layer","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"layer2 = mask(layer1, layer2);\nlayer3 = mask(layer1, layer3);\nnothing #hide","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"Note that bivariate maps usually work best when used with 9 classes in total (so 3 for each side). The next decision is to take a bivaraite color palette, and the combinations below are commonly used. Note that you can definitely use diverging colors if you want. If you use colors in the RGBA format (e.g. colorant\"#ef0ce8c4\"), the color map will account for transparency.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"p0 = colorant\"#e8e8e8\"\nbv_pal_1 = (p0=p0, p1=colorant\"#64acbe\", p2=colorant\"#c85a5a\")\nbv_pal_2 = (p0=p0, p1=colorant\"#73ae80\", p2=colorant\"#6c83b5\")\nbv_pal_3 = (p0=p0, p1=colorant\"#9972af\", p2=colorant\"#c8b35a\")\nbv_pal_4 = (p0=p0, p1=colorant\"#be64ac\", p2=colorant\"#5ac8c8\")","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"The bivariate map itself is a call to plot. Internally, this will transform the layers into quantiles (determined by the classes keyword, defaults to 3):","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"plot(layer1, layer3; st=:bivariate, bv_pal_3...)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"Note that you can use the bivariate shorthand as well:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"pl1 = bivariate(layer1, layer3; classes=3, frame=:box, bv_pal_4...)\nxaxis!(pl1, \"Longitude\")\nyaxis!(pl1, \"Latitude\")","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"We can repeat essentially the same process for the legend:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"pl2 = bivariatelegend(layer1, layer3; classes=3, bv_pal_4...)\nxaxis!(pl2, layernames(EarthEnv, HabitatHeterogeneity, 2))\nyaxis!(pl2, layernames(EarthEnv, LandCover, 9))","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"And now, we can plot the legend next to the map - future releases of the package will hopefully offer this in a far more user friendly way.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"plot(pl1, pl2; layout=@layout [a{0.75w} b])","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"Using the subplot and inset arguments of Plots.jl, we can have the legend within the figure. Note how in this example we expand the limits on the x axis to make the legend fit, but also use more classes in the map to have a smoother result.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"p1 = bivariate(\n    layer1,\n    layer3;\n    classes=6,\n    bv_pal_2...,\n    frame=:box,\n    xlim=(-24, maximum(longitudes(layer1))),\n)\nxaxis!(p1, \"Longitude\")\nyaxis!(p1, \"Latitude\")\np2 = bivariatelegend!(\n    layer1,\n    layer3;\n    bv_pal_2...,\n    inset=(1, bbox(0.04, 0.05, 0.28, 0.28, :top, :left)),\n    subplot=2,\n    xlab=layernames(EarthEnv, HabitatHeterogeneity, 2),\n    ylab=layernames(EarthEnv, LandCover, 9),\n    guidefontsize=7,\n)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"Using a trivariate mapping follows the same process, with layers representing the red, green, and blue channel respectively.","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"plot(layer1, layer2, layer3; st=:trivariate, frame=:grid)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"There are two options for this type of plots. The first is quantiles=true (which maps quantiles rather than raw values), and the second is simplex=false, which makes all values sum to 1 within a pixel. For example:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"trivariate(layer1, layer2, layer3; quantiles=true, simplex=true, frame=:grid)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"It is a good idea to question whether using simplex is appropriate. The legend can also be plotted using trivariatelegend:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"trivariatelegend(layer1, layer2, layer3; quantiles=true, simplex=true)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"The legend function admits three additional arguments for the names of the red, green, and blue channels:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"trivariatelegend(\n    layer1,\n    layer2,\n    layer3;\n    quantiles=true,\n    simplex=true,\n    red=\"Heterogeneous\",\n    green=\"Rough\",\n    blue=\"Urbanized\",\n)","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"We can also combine the two elements:","category":"page"},{"location":"examples/multivariate/","page":"Multivariate mapping","title":"Multivariate mapping","text":"tri1 = trivariate(\n    layer1,\n    layer2,\n    layer3;\n    xlim=(-24, maximum(longitudes(layer1))),\n    frame=:grid,\n    grid=false,\n    simplex=false,\n)\nxaxis!(tri1, \"Longitude\")\nyaxis!(tri1, \"Latitude\")\ntri2 = trivariatelegend!(\n    layer1,\n    layer2,\n    layer3;\n    inset=(1, bbox(0.01, 0.03, 0.35, 0.35, :top, :left)),\n    subplot=2,\n    red=\"Heterogeneity\",\n    green=\"Roughness\",\n    blue=\"Urban\",\n    annotationfontsize=6,\n    simplex=false,\n)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/pseudoabsences.jl\"","category":"page"},{"location":"sdm/pseudoabsences/#Generating-pseudo-absences","page":"Pseudo-absences","title":"Generating pseudo absences","text":"","category":"section"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"using SimpleSDMLayers\nusing Plots\nusing GBIF\nusing StatsBase","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"Justification for this use case: by contrast to the BIOCLIM model from the previous use case, many models require background knowledge about where the species is not, which is rarely available. For this reason, we often need to resort to generating pseudo-absences, by applying various guesses based on where we know species are.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"In this example, we will see how to generate pseudo-absences (according to Barbet-Massin et al.) using three methods: radius-based, surface range envelope, and random selection. To begin with, we will occurrences for the Lobster mushroom in Canada and the US.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"sp = GBIF.taxon(\"Hypomyces lactifluorum\")\nobservations = occurrences(sp, \"hasCoordinate\" => true, \"limit\" => 300, \"country\" => \"CA\", \"country\" => \"US\")\nwhile length(observations) < size(observations)\n    occurrences!(observations)\nend","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"In order to have a layer to start working, we will get the precipitation layer:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"layer = clip(SimpleSDMPredictor(WorldClim, BioClim, 12), observations)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"We can visualize the results of this query:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"plot(layer, c=:devon)\nscatter!(longitudes(observations), latitudes(observations), lab=\"\", msw=0.0, ms=1, c=:orange)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"The first step here is to remove the redundancy in observations: multiple observations in the same cell do not really convey a lot of information. For this reason, we can create a very sparse layer with only presences:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"presences = mask(layer, observations, Bool)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"This is enough to start generating pseudo-absences. We will first use the RandomSelection method, which will pick positions anywhere on the layer except in places that are already occupied. Because our species has one occurrence far away in Alaska this might not be  the best method, but this is a simple one to grasp.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"rs_pa = rand(RandomSelection, presences)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"We can plot this layer to see what it looks like:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"plot(convert(Float32, rs_pa), c=:Greys, leg=false)\nscatter!(longitudes(observations), latitudes(observations), lab=\"\", msw=0.0, ms=1, c=:orange)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"This is obviously not ideal, as there are pseudo-absences very far from the observations. An alternative is to use the SurfaceRangeEnvelope method, which is limited to the bounding box of observations.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"sre_pa = rand(SurfaceRangeEnvelope, presences)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"We can plot this layer to see what it looks like:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"plot(convert(Float32, sre_pa), c=:Greys, leg=false)\nscatter!(longitudes(observations), latitudes(observations), lab=\"\", msw=0.0, ms=1, c=:orange)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"It is a little bit better, but the extreme point means that the surface range envelope is very large – in addition, the species has a distribution with large gaps in it, so we are going to experiment with the WithinRadius method.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"This method will allow pseudo-absences to be within a set distance (expressed in degrees) of any given observation, excluding the grid cells for which we already have an observation. The default distance is 1 degree.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"wr_one_pa = rand(WithinRadius, presences)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"This function can take a little longer to run, as it involves a clipping step based on circles around the presences; this will be optimized in the future.","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"We can plot this layer to see what it looks like:","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"plot(convert(Float32, wr_one_pa), c=:Greys, leg=false)\nscatter!(longitudes(observations), latitudes(observations), lab=\"\", msw=0.0, ms=1, c=:orange)","category":"page"},{"location":"sdm/pseudoabsences/","page":"Pseudo-absences","title":"Pseudo-absences","text":"This is a much better distribution of pseudo-absences! Of course, the consequences of which pseudo-absence method to pick is key in the accuracy of the model. The WithinRadius method may not always perform better. In fact, in the Boosted Regression Tree exmaple, we will see how SurfaceRangeEnvelope gives excellent results.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/gbif.jl\"","category":"page"},{"location":"sdm/gbif/#Working-with-GBIF-data","page":"GBIF integration","title":"Working with GBIF data","text":"","category":"section"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"Justification for this use case: building species distribution models requires information of where species are. In this document, we will see how the SimpleSDMLayers and GBIF packages interact, as a first step to get in a usable state. Specifically, we will work on the occurences of the relationship between temperature and precipitation for a few occurrences of the fungus Hypomyces lactifluorum, which will be the taxon used for all SDM-related vignettes.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"using SimpleSDMLayers\nusing GBIF\nusing Plots\nusing Statistics","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We will focus on showing where on the temperature/precipitation space the occurrences are, so we will download these layers:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"temperature, precipitation = SimpleSDMPredictor(WorldClim, BioClim, [1, 12])","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"And now, we can follow the GBIF documentation to get some occurrences","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"observations = occurrences(\n    GBIF.taxon(\"Hypomyces lactifluorum\"; strict=true),\n    \"hasCoordinate\" => \"true\",\n    \"country\" => \"CA\",\n    \"country\" => \"US\",\n    \"limit\" => 300,\n)\nwhile length(observations) < size(observations)\n    occurrences!(observations)\nend\n\n@info observations","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can then extract the temperature for the first occurrence:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"temperature[observations[1]]","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"Of course, it would be unwieldy to do this for every occurrence in our dataset, and so we will see a way do it much faster. But first, we do not need the entire surface of the planet to perform our analysis, and so we will instead clip the layers:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"temperature = clip(temperature, observations)\nprecipitation = clip(precipitation, observations)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"This will make the future queries a little faster. By default, the clip function will ad a 5% margin on every side. To get the values of a layer at every occurrence in a GBIFRecord, we simply pass the records as a position:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"histogram2d(temperature, precipitation; c=:devon, frame=:zerolines, leg=false, lab=\"\")\nscatter!(\n    temperature[observations],\n    precipitation[observations];\n    lab=\"\",\n    c=:white,\n    msc=:orange,\n    alpha=0.2,\n)\nxaxis!(\"Temperature (°C)\")\nyaxis!(\"Precipitation (mm)\")","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"This will return a record of all data for all geo-localized occurrences (i.e. neither the latitude nor the longitude is missing) in a GBIFRecords collection, as an array of the eltype of the layer. Note that the layer values can be nothing, in which case you might need to run filter(!isnothing, temperature_clip[kf_occurrences] for it to work with the plotting functions.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can also plot the records over space, using the overloads of the latitudes and longitudes functions:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"contour(temperature; c=:cork, frame=:box, fill=true, clim=(-20, 20), levels=6)\nscatter!(\n    longitudes(observations), latitudes(observations); lab=\"\", c=:white, msc=:orange, ms=2\n)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can finally make a layer with the number of observations per cells:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"presabs = mask(temperature, observations, Float32)\nplot(log1p(presabs); c=:tokyo)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"Because the cells are rather small, and there are few observations, this is not necessarily going to be very informative - to get a better sense of the distribution of observations, we can get the average number of observations in a radius of 100km around each cell (we will do so for a zoomed-in part of the map to save time):","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"zoom = clip(presabs; left=-80.0, right=-65.0, top=50.0, bottom=40.0)\nbuffered = slidingwindow(zoom, Statistics.mean, 100.0)\nplot(buffered; c=:tokyo, frame=:box)\nscatter!(\n    longitudes(observations),\n    latitudes(observations);\n    lab=\"\",\n    c=:white,\n    msc=:orange,\n    ms=2,\n    alpha=0.5,\n)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/sdm/brt.jl\"","category":"page"},{"location":"sdm/brt/#BRTs-for-species-distribution-forecasting","page":"BRTs and climate change","title":"BRTs for species distribution forecasting","text":"","category":"section"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"using SimpleSDMLayers\nusing EvoTrees\nusing GBIF\nusing StatsBase\nusing StatsPlots","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Justification for this use case: Boosted Regression Trees (BRTs) are a powerful way to predict the distribution of species. We will see how we can get information in and out of layers to use them, and how to use this model to predict a new distribution under a climate change scenario. This use-case assumes that you have read the manual pages for GBIF integration, future data, and pseudo-absences generation.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We will re-use the data from the pseudo-absences example:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"sp = GBIF.taxon(\"Hypomyces lactifluorum\")\nobservations = occurrences(\n    sp, \"hasCoordinate\" => true, \"limit\" => 300, \"country\" => \"CA\", \"country\" => \"US\"\n)\nwhile length(observations) < size(observations)\n    occurrences!(observations)\nend","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We will pick the entire BioClim layers at a 10 minutes resolution, and clip them to the observations (this adds a 5 degrees buffer).","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"layers = [\n    clip(layer, observations) for layer in SimpleSDMPredictor(WorldClim, BioClim, 1:19)\n];\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"To remove the sampling effect, we transform the presences to a grid, and generate pseudo-absences using the surface range envelope method.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"presences = mask(layers[1], observations, Bool)\nabsences = rand(SurfaceRangeEnvelope, presences)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The next step is to extract coordinates at which the species is present or pseudo-absent - we can rely on the replace method to empty any false values:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"xy_presence = keys(replace(presences, false => nothing));\nxy_absence = keys(replace(absences, false => nothing));\nxy = vcat(xy_presence, xy_absence);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"With the xy list of coordinates, we can get a predictor X, and a response y.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"X = hcat([layer[xy] for layer in layers]...);\ny = vcat(fill(1.0, length(xy_presence)), fill(0.0, length(xy_absence)));\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"To train the model, we will use a random subset representing 70% of the dataset:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"train_size = floor(Int, 0.7 * length(y));\ntrain_idx = sample(1:length(y), train_size; replace=false);\ntest_idx = setdiff(1:length(y), train_idx);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"This gives use the training and testing (or evaluation) sets:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Xtrain, Xtest = X[train_idx, :], X[test_idx, :];\nYtrain, Ytest = y[train_idx], y[test_idx];\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"In order to fit the tree, we need to define a number of parameters. We will use a Gaussian maximum likelihood tree (from EvoTrees), which will give us a measure of the average prediction, but also the standard deviation. This is important in order to communicate uncertainty.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"gaussian_tree_parameters = EvoTreeGaussian(;\n    loss=:gaussian,\n    metric=:gaussian,\n    nrounds=100,\n    nbins=100,\n    λ=0.0,\n    γ=0.0,\n    η=0.1,\n    max_depth=7,\n    min_weight=1.0,\n    rowsample=0.5,\n    colsample=1.0,\n)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can now fit the BRT. This function has an additional print_every_n to update on the progress every n epochs, but we don't really need it here.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"model = fit_evotree(gaussian_tree_parameters, Xtrain, Ytrain; X_eval=Xtest, Y_eval=Ytest)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The next step is to gather all the values of all the layers in a matrix, in order to run the full spatial prediction:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"all_values = hcat([layer[keys(layer)] for layer in layers]...);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"If the matrix is too big, we could resort to a combination of clip, make the prediction on each tile, and then use hcat and vcat to combine them. This is not the case here, so we can predict directly:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"pred = EvoTrees.predict(model, all_values);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Once the prediction is done, we can copy the values into a layer.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"distribution = similar(layers[1], Float64)\ndistribution[keys(distribution)] = pred[:, 1]\ndistribution","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The BRT is able to calculate a measure of relative gain from the different variables:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"top5_var = importance(model, collect(layernames(WorldClim, BioClim)))[1:5]","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"This is an interesting alternative to VIF for variable selection. Let's examine how the most important variable relates to the predicted distribution score:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"most_important_layer = findfirst(isequal(top5_var[1].first), collect(layernames(WorldClim, BioClim)))\nhistogram(\n    layers[most_important_layer][xy_presence]; fill=(0, :teal, 0.2), lc=:teal, frame=:origin, lab=\"Present\"\n)\nhistogram!(\n    layers[most_important_layer][xy_absence]; fill=(0, :white, 0.0), frame=:origin, lc=:grey, lab=\"Absent\"\n)\nxaxis!(layernames(WorldClim, BioClim, most_important_layer))","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"It is interesting to notice that despite the importance of this predictor, the difference between the presence and absence locations are not as clear as we may expect!","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can similarly extract uncertainty:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"uncertainty = similar(layers[1], Float64)\nuncertainty[keys(uncertainty)] = pred[:, 2]\nuncertainty","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"And we can now visualize the prediction, which we force to be in [0,1].","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"p_dis = plot(rescale(distribution, (0, 1)); c=:bamako, frame=:box)\nscatter!(xy_presence; lab=\"\", c=:black, alpha=0.2, msw=0.0, ms=3)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can do the same thing for the uncertainty","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"p_unc = plot(uncertainty; c=:tokyo, frame=:box)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Of course, this prediction is returing values for the entire range of the initial layer, so let's compare the distributions of the prediction score:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"histogram(\n    distribution[xy_presence]; fill=(0, :teal, 0.2), lc=:teal, frame=:origin, lab=\"Present\"\n)\nhistogram!(\n    distribution[xy_absence]; fill=(0, :white, 0.0), frame=:origin, lc=:grey, lab=\"Absent\"\n)\nxaxis!(\"Prediction score\")","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"This looks like a good opportunity to do some thresholding. Note that the values are not moved back to the unit range, because we'll need the raw values for a little surprise later on. We will find the value of the score that optimizes Youden's J (Cohen's κ is also a suitable alternative):","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"cutoff = LinRange(extrema(distribution)..., 500);\n\nobs = y .> 0\n\ntp = zeros(Float64, length(cutoff));\nfp = zeros(Float64, length(cutoff));\ntn = zeros(Float64, length(cutoff));\nfn = zeros(Float64, length(cutoff));\n\nfor (i, c) in enumerate(cutoff)\n    prd = distribution[xy] .>= c\n    tp[i] = sum(prd .& obs)\n    tn[i] = sum(.!(prd) .& (.!obs))\n    fp[i] = sum(prd .& (.!obs))\n    fn[i] = sum(.!(prd) .& obs)\nend","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"From this, we can calculate a number of validation measures:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"tpr = tp ./ (tp .+ fn);\nfpr = fp ./ (fp .+ tn);\nJ = (tp ./ (tp .+ fn)) + (tn ./ (tn .+ fp)) .- 1.0;\nppv = tp ./ (tp .+ fp);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The ROC-AUC is an overall measure of how good the fit is:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"dx = [reverse(fpr)[i] - reverse(fpr)[i - 1] for i in 2:length(fpr)]\ndy = [reverse(tpr)[i] + reverse(tpr)[i - 1] for i in 2:length(tpr)]\nAUC = sum(dx .* (dy ./ 2.0))","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can pick the value of the cutoff that maximizes J:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"thr_index = last(findmax(J))\nτ = cutoff[thr_index]","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Let's have a look at the ROC curve:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(fpr, tpr; aspectratio=1, frame=:box, lab=\"\", dpi=600, size=(400, 400))\nscatter!([fpr[thr_index]], [tpr[thr_index]]; lab=\"\", c=:black)\nplot!([0, 1], [0, 1]; c=:grey, ls=:dash, lab=\"\")\nxaxis!(\"False positive rate\", (0, 1))\nyaxis!(\"True positive rate\", (0, 1))","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"And the precision-recall as well:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(tpr, ppv; aspectratio=1, frame=:box, lab=\"\", dpi=600, size=(400, 400))\nscatter!([tpr[thr_index]], [ppv[thr_index]]; lab=\"\", c=:black)\nplot!([0, 1], [1, 0]; c=:grey, ls=:dash, lab=\"\")\nxaxis!(\"True positive rate\", (0, 1))\nyaxis!(\"Positive predictive value\", (0, 1))","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can now map the result using τ as a cutoff for the distribution data:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"range_mask = broadcast(v -> v >= τ, distribution)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"And finally, plot the whole thing:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(distribution; c=:lightgrey, leg=false)\nplot!(mask(range_mask, distribution); c=:darkgreen)\nscatter!(xy_presence; lab=\"\", c=:orange, alpha=0.5, msw=0.0, ms=2)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Because our BRT also returns the uncertainty, we can combine both maps into a bivariate one, showing both where we expect the species, but also where we are uncertain about the prediction:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(distribution; leg=false, c=:lightgrey, frame=:grid, xlab=\"Longitude\", ylab=\"Latitude\", grid=false)\nbivariate!(mask(range_mask, distribution), mask(range_mask, uncertainty))\np2 = bivariatelegend!(\n    mask(range_mask, distribution),\n    mask(range_mask, uncertainty);\n    inset=(1, bbox(0.04, 0.08, 0.23, 0.23, :center, :left)),\n    subplot=2,\n    xlab=\"Prediction\",\n    ylab=\"Uncertainty\",\n    guidefontsize=7,\n)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"Now, for the big question - will this range move in the future? To explore this, we will get the same variables, but in the future. In order to simplify the code, we will limit ourselves to one SSP (585) and one CMIP6 model (CanESM5), around 2050:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"future_layers = [\n    clip(layer, observations) for\n    layer in SimpleSDMPredictor(WorldClim, BioClim, CanESM5, SSP585, 1:19; year=\"2041-2060\")\n];\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can get all the future values from this data:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"all_future_values = hcat([layer[keys(layer)] for layer in future_layers]...);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"And make a prediction based on our BRT model. This is, of course, assuming that BRTs are good at this type of prediction (they're OK).","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"future_pred = EvoTrees.predict(model, all_future_values);\nnothing #hide","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"As before, we also have a measure of uncertainty. In the interest of keeping this vignette small, we will not look at it.","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"future_distribution = similar(layers[1], Float64)\nfuture_distribution[keys(future_distribution)] = future_pred[:, 1]\nfuture_distribution","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The values in future_distribution are in the scale of what the BRT returns, so we can compare them with the values of distribution:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(future_distribution - distribution; clim=(-1, 1), c=:broc, frame=:box)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"This shows the area of predicted gain and loss of presence. Because we have thresholded our current distribution, we can look at the predicted ranges of suitability:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"future_range_mask = broadcast(v -> v >= τ, future_distribution)","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"The last step is to get the difference between the future and current masks (so +1 is a gain of range, 0 is no change, and -1 is a loss), and to only report this for the cells that are both in the current and future data:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"range_change = convert(Float32, future_range_mask) - convert(Float32, range_mask)\nboth_ranges_mask = maximum([future_range_mask, range_mask])","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"We can now plot the result, with the brown area being range that becomes unfavorable, the green one remaining suitable, and the blue area being newly opened range:","category":"page"},{"location":"sdm/brt/","page":"BRTs and climate change","title":"BRTs and climate change","text":"plot(distribution; c=:lightgrey, leg=false)\nplot!(mask(both_ranges_mask, range_change); c=:roma)","category":"page"},{"location":"man/changevalues/#Operations-on-values","page":"Operations on values","title":"Operations on values","text":"","category":"section"},{"location":"man/changevalues/","page":"Operations on values","title":"Operations on values","text":"rescale!\nrescale\nreplace\nreplace!","category":"page"},{"location":"man/changevalues/#SimpleSDMLayers.rescale!","page":"Operations on values","title":"SimpleSDMLayers.rescale!","text":"rescale!(layer::TI, template::TJ) where {TI <: SimpleSDMLayer, TJ <: SimpleSDMLayer}\n\nChanges the values of the layer given as its first argument, so that it has the same range as the values of the layer given as its second argument. Modification is done in-place.\n\n\n\n\n\nrescale!(layer::TI, t::Tuple{T,T}) where {TI <: SimpleSDMLayer, T <: Number}\n\nChanges the values of the layer given as its first argument, so that it has the same range as the values given as a tuple of values. Modification is done in-place.\n\n\n\n\n\nrescale!(layer::T, p::Vector{Real}) where {T <: SimpleSDMLayer}\n\nRescale the values of a layer so that they match with the quantiles given in p. Internally, this uses the Statistics.quantile function.\n\n\n\n\n\n","category":"function"},{"location":"man/changevalues/#SimpleSDMLayers.rescale","page":"Operations on values","title":"SimpleSDMLayers.rescale","text":"rescale(layer::TI, template::TJ) where {TI <: SimpleSDMLayer, TJ <: SimpleSDMLayer}\n\nCopying version of rescale!.\n\n\n\n\n\nrescale(layer::TI, t::Tuple{T,T}) where {TI <: SimpleSDMLayer, T <: Number}\n\nCopying version of rescale!.\n\n\n\n\n\nrescale(layer::T, p::Vector{Real}) where {T <: SimpleSDMLayer}\n\nCopying version of rescale!.\n\n\n\n\n\n","category":"function"},{"location":"man/changevalues/#Base.replace","page":"Operations on values","title":"Base.replace","text":"Base.replace(layer::T, old_new::Pair...) where {T <: SimpleSDMResponse}\n\nReplaces the elements of layer according to a series of pairs. Returns a copy.\n\n\n\n\n\nBase.replace(layer::T, old_new::Pair...) where {T <: SimpleSDMPredictor}\n\nReplaces the elements of layer according to a series of pairs. Copies the layer as a response before.\n\n\n\n\n\n","category":"function"},{"location":"man/changevalues/#Base.replace!","page":"Operations on values","title":"Base.replace!","text":"Base.replace!(layer::T, old_new::Pair...) where {T <: SimpleSDMLayer}\n\nReplaces the elements of layer according to a series of pairs. In place. Only possible for SimpleSDMResponse elements (which are mutable) and will throw an error if called on a SimpleSDMPredictor element (which is not mutable).\n\n\n\n\n\n","category":"function"},{"location":"man/changevalues/","page":"Operations on values","title":"Operations on values","text":"broadcast","category":"page"},{"location":"#Simple-SDM-Layers-in-*Julia*","page":"Home","title":"Simple SDM Layers in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SimpleSDMLayers provides an interface to facilitate the manipulation of raster data for species distributions modeling in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The two core types of the package are SimpleSDMPredictor and SimpleSDMResponse. The only difference between the two is that predictors are immutable, but responses are. All types belong to the abstract SimpleSDMLayer, and are organised in the same way: a grid field storing a matrix of data (of any type!), and the left, right, bottom, and top coordinates (as floating point values). Of course these details are largely irrelevant, since we have overloaded a large number of methods from Base, to make indexing, converting, and modifying data as easy as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim of the package is to deliver (i) a series of methods to manipulate raster data, and (ii) facilitated access to common datasets used to train species distribution models. Despite what the name may suggest, this package does not implement SDMs, but is instead intended as a library usable for this purpose. Nevertheless, the documentation contains a few example of building models, and integrating this package with the GBIF API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentations is split in three sections. The manual is a fairly exhaustive documentation of the functions, methods, types, and interfaces, and it is a good idea to skim it first, and come back for a focused reading when you have a specific use-case in mind. The general examples section is a collection of mostly disconnected workflows, intended to show how SimpleSDMLayers interacts with other packages. It should give you a better understanding of you can actually use the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the SDM case studies are a more linear series of vignettes, covering occurrence data, variable selection, bulding a presence-only model, generating pseudo-absences, and using a machine learning approach to do range forecasting under climate change. This last section can be used as a template to develop new analyses, and will use almost all the features in the package. All of the SDM vignettes use the same species throughout - Hypomyces lactifluorum is a fungus of moderate commerical importance in North America, whose distribution is probably going to be affected by climate change.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"EditURL = \"https://github.com/EcoJulia/SimpleSDMLayers.jl/docs/src/examples/landcover.jl\"","category":"page"},{"location":"examples/landcover/#Landcover-data","page":"Landcover data","title":"Landcover data","text":"","category":"section"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"In this example, we will look at landcover data in Corsica","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"using SimpleSDMLayers\nusing Plots","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"To avoid loading the (rather large) dataset of land cover at once, we will rely on a bounding box:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"boundaries = (left=8.25, right=10.0, bottom=41.2, top=43.2)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"The numbers corresponding to the layers can be found in the documentation for SimpleSDMPredictor - urban area is 9.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"urban = SimpleSDMPredictor(EarthEnv, LandCover, 9; boundaries...)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"This dataset is returning data as UInt8 (as it represents a proportion of the pixel occupied by the type), but this is not something that can be plotted efficiently (because we rely on NaN to indicate no data, and UInt8 has no NaN). So in the next step, we will manipulate this object a little bit to have something more workable.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"urban = convert(Float16, urban)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"Why Float16? It is the smallest floating point type with a NaN value (NaN16). We will replace the values of 0 by nothing, to only see the pixels with at least some urban cover:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"replace!(urban, zero(eltype(urban)) => nothing)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"With this done, we can plot the results:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"plot(urban; c=:berlin, clim=(0, 100))","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"Unsuprisingly to anyone who had the chance to visit Corsica, it is not a very densely urbanized island. This is a good time to question whether we can look at (i) which landcover type dominates within each pixel, and (ii) how heterogeneous the land use within each pixel is.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"First, we will download all values for the landcover layers, including open water (12).","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"landcover =\n    convert.(\n        Float16, SimpleSDMPredictor(EarthEnv, LandCover, 1:12; full=false, boundaries...)\n    )\n\nplot(\n    plot.(landcover, leg=false, c=:oleron, clim=(0, 100))...;\n    leg=false,\n    grid=:none,\n    frame=:none,\n)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"To perform the actual analysis, we will define a shannon function, which will return the entropy of the land use categories:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"function shannon(x)\n    v = filter(n -> n > zero(eltype(x)), x)\n    length(v) == 0 && return NaN\n    v = v ./ sum(v)\n    return -sum(v .* log2.(v))\nend\n\nentropy = mosaic(shannon, landcover)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"We can also get the index of the most common layer within the pixel:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"consensus = mosaic(x -> last(findmax(x)), landcover)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"We may not be that interested in fully open water, so let's define a mask to remove it:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"openwater = broadcast(!isequal(12), consensus)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"All that's left to do is to plot after applying this mask, and we now get a map of most common land cover type (left), and land cover heterogeneity (right)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"p1 = plot(mask(openwater, consensus); c=:terrain, frame=:none)\np2 = plot(mask(openwater, entropy); c=:lapaz, frame=:none)\nplot(p1, p2)","category":"page"}]
}
