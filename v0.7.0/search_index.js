var documenterSearchIndex = {"docs":
[{"location":"examples/landcover/#Getting-landcover-data","page":"Landcover data","title":"Getting landcover data","text":"","category":"section"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"In this example, we will look at landcover data, specifically the proportion of urban/built area in Europe; the entire dataset is very large to fit in memory, as it has a resolution of about 1 kilometre squared. Therefore, we will take advantage of the ability to only load the part that matters by passing the limits of a bounding box.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"using SimpleSDMLayers\nurban = SimpleSDMPredictor(EarthEnv, LandCover, 9; left=-11.0, right=31.1, bottom=29.0, top=71.1)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"This dataset is returning data as UInt8 (as it represents a proportion of the pixel occupied by the type), but this is not something that can be plotted efficiently. So in the next step, we will manipulate this object a little bit to have something more workable.","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"urban = convert(Float32, urban)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"We will replace the values of 0 by nothing, to only see the pixels with some urban cover:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"replace!(urban, zero(eltype(urban)) => nothing)","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"With this done, we can plot the results:","category":"page"},{"location":"examples/landcover/","page":"Landcover data","title":"Landcover data","text":"using Plots\nheatmap(urban, c=:berlin)","category":"page"},{"location":"examples/slidingwindow/#Sliding-window-analysis","page":"Sliding window analysis","title":"Sliding window analysis","text":"","category":"section"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"In this example, we will get precipitation data from Québec, and use a sliding window analysis to smooth them out. The beginning of the code should now be familiar:","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"using SimpleSDMLayers\nusing Plots\nusing Statistics\n\nprecipitation = SimpleSDMPredictor(WorldClim, BioClim, 12; left=-80.0, right=-56.0, bottom=44.0, top=62.0)","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"The sliding window works by taking all pixels within a given radius (expressed in kilometres) around the pixel of interest, and then applying the function given as the second argument to their values. Empty pixels are removed. In this case, we will do a summary across a 100 km radius around each pixel:","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"averaged = slidingwindow(precipitation, Statistics.mean, 100.0)","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"We can finally overlap the two layers – the result of sliding window is a little bit smoother than the raw data.","category":"page"},{"location":"examples/slidingwindow/","page":"Sliding window analysis","title":"Sliding window analysis","text":"plot(precipitation, c=:alpine)\ncontour!(averaged, c=:white, lw=2.0)","category":"page"},{"location":"sdm/future/#Future-climate-data","page":"Future data","title":"Future climate data","text":"","category":"section"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"For some dta providers and datasets, SimpleSDMLayers offers access to future climate data. Future climates are usually specified by a model, and a scenario. For example, WorldClim 2.1 offers the full suite of BioClim variable under four SSPs and a number of CMIP6 models.","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"We can use this to look at, for example, the temperature difference between the current and future climate. To illustrate this, we will do a simple example where we contrast the \"historical\" climate (i.e. what is assumed to be the current data) to the projected  data under SSP585 in the 2041-2060 period.","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"using SimpleSDMLayers\nusing Plots\nusing Statistics","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"We will start by getting the contemporary data:","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"baseline = SimpleSDMPredictor(WorldClim, BioClim, 1; left=60.0, right=95.0, bottom=0.0, top=40.0)\nplot(baseline, frame=:box, c=:heat)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"To get a future dataset, we need to specify the model:","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"instances(CMIP6)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"And we need to check the names of the SSP we want to use:","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"instances(SharedSocioeconomicPathway)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"We can now get our future temperature layer (and plot it):","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"future = SimpleSDMPredictor(WorldClim, BioClim, CanESM5, SSP585, 1; year=\"2041-2060\", left=60.0, right=95.0, bottom=0.0, top=40.0)\nplot(future, frame=:box, c=:heat)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"Note that the call to get the future data is almost the same as the historical one - the exception is the addition of the model and scenario, and the specification of the years.","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"With this layer, we can now measure the difference in mean annual temperature:","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"plot(future - baseline, c=:lapaz, frame=:box)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"We might actually be interested in averaging multiple models. Because we know the variety of models worldclim has (instances(CMIP6)), we can do this fairly easily. One of the model has no predictions for SSP585 (which we would learn in the form of an error message), so we will filter it out directly.","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"ensemble = [\n    SimpleSDMPredictor(\n        WorldClim, BioClim, model, SSP585, 1;\n        year=\"2041-2060\", left=60.0, right=95.0, bottom=0.0, top=40.0\n    ) for model in instances(CMIP6) if model != GFDLESM4\n];","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"We will measure the difference of each layer to the baseline:","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"differences = [component - baseline for component in ensemble]\nplot(plot.(differences, c=:lapaz)..., frame=:box)","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"From this, we can look at the average difference (across multiple models):","category":"page"},{"location":"sdm/future/","page":"Future data","title":"Future data","text":"plot(mosaic(mean, differences), c=:lapaz, frame=:box)","category":"page"},{"location":"sdm/bioclim/#Writing-BIOCLIM-from-scratch","page":"BIOCLIM from scratch","title":"Writing BIOCLIM from scratch","text":"","category":"section"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"In this example, we will write the BIOCLIM species distribution model using SimpleSDMLayers.jl and GBIF.jl.","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"using SimpleSDMLayers\nusing GBIF\nusing Plots\nusing StatsBase\nusing Statistics","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"We can get some occurrences for the taxon of interest:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"obs = occurrences(\n    GBIF.taxon(\"Alces alces\", strict=true),\n    \"hasCoordinate\" => \"true\",\n    \"continent\" => \"EUROPE\",\n    \"limit\" => 50\n)\nwhile length(obs) < min(2000, size(obs))\n    occurrences!(obs)\nend","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"This query uses a range for the longitude and latitude, so as to make sure that we get a relatively small region. Before we get the layers, we will figure out the bounding box for the observations - just to make sure that we will have something large enough, we will add a 2 degrees padding around it:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"left, right = extrema([o.longitude for o in obs]) .+ (-5,5)\nbottom, top = extrema([o.latitude for o in obs]) .+ (-5,5)","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"With this information in hand, we can start getting our variables. In this example, we will take all worldclim data, at the default 10 arc minute resolution:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"predictors = SimpleSDMPredictor(WorldClim, BioClim, 1:19; left=left, right=right, bottom=bottom, top=top);\nfirst(predictors)","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"The point of BIOCLIM (the model, not the dataset) is that the score assigned to a pixel is maximal is this pixel is the median value for a given variable - therefore, we need to measure the cumulative density function for every pixel in every variable.","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"_pixel_score(x) = 2.0(x > 0.5 ? 1.0-x : x)\n\nfunction SDM(layer::T, observations::GBIFRecords) where {T <: SimpleSDMLayer}\n    qf = ecdf(layer[observations]) # We only want the observed values\n    return (_pixel_score∘qf)\nend","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"Note that we use the ∘ (\\circ) operator to chain the quantile estimation and the pixel scoring, which requires Julia 1.4. This function returns a model, i.e. a function that we can broadcast to a given layer, which might not be the same one we used for the training.","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"The next step in BIOCLIM is to get the minimum suitability across all layers for every pixel. Because we have a min method defined for a pair of layers, we can call minimum on an array of layers:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"function SDM(predictors::Vector{T}, models) where {T <: SimpleSDMLayer}\n    @assert length(models) == length(predictors)\n    return minimum([broadcast(models[i], predictors[i]) for i in 1:length(predictors)])\nend","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"The advantage of this approach is that we can call the SDM method for prediction on a smaller layer, or a different layer. This can allow us to do thing like stitching layers together with hcat and vcat to use multi-threading, or use a different resolution for the prediction than we did for the training.","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"models = [SDM(predictor, obs) for predictor in predictors]\nprediction = SDM(predictors, models)","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"Just because we may want to visualize this result in a transformed way, i.e. by looking at the quantiles of suitability, we can call the rescale! function:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"rescale!(prediction, collect(0.0:0.01:1.0))","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"As this map now represents the quantiles of suitability, we may want to remove the lower 5%. For this, we need to create a boolean mask, which we can do by broadcasting a conditional:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"cutoff = broadcast(x -> x > 0.05, prediction)","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"This map can be plotted as we would normally do:","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"plot(prediction, frame=:box, c=:lightgrey) # Plot a uniform background\nplot!(mask(cutoff, prediction), clim=(0,1), c=:bamako)\nscatter!([(o.longitude, o.latitude) for o in obs], ms=4, c=:orange, lab=\"\")\nxaxis!(\"Longitude\")\nyaxis!(\"Latitude\")","category":"page"},{"location":"sdm/bioclim/","page":"BIOCLIM from scratch","title":"BIOCLIM from scratch","text":"And there it is! A simple way to write the BIOCLIM model by building on the integration between SimpleSDMLayers and GBIF.","category":"page"},{"location":"man/operations/#Other-operations","page":"Other operations","title":"Other operations","text":"","category":"section"},{"location":"man/operations/","page":"Other operations","title":"Other operations","text":"coarsen\nslidingwindow\nlatitudes\nlongitudes\nboundingbox\nclip\nmask\nrescale!\nrescale\nmosaic","category":"page"},{"location":"man/operations/#SimpleSDMLayers.coarsen","page":"Other operations","title":"SimpleSDMLayers.coarsen","text":"coarsen(L::LT, f::FT, d::Tuple{IT,IT}) where {LT <: SimpleSDMLayer, FT <: Function, IT <: Integer}\n\nThis function will aggregate a layer by merging cells. The function f passed as its second argument is expected to take an array as input, and return a single value of any type (but it is sort of a social contract here that this will be a number of some sort, and if it is not, that you really know what you're doing).\n\nThe size of the cells to aggregate is given by the tuple, so that (2,2) will make groups of two cells vertically and two cells horizontally, for a total of four cells. By default, the cells containing nothing will be ignored, so that f is only applied to non-nothing values.\n\nIn cases where the number of cells to aggregate is not matching with the size of the grid, and ArgumentError will be thrown. Note that there is no expectation that the two values in d will be the same.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.slidingwindow","page":"Other operations","title":"SimpleSDMLayers.slidingwindow","text":"slidingwindow(L::LT, f::FT, d::IT) where {LT <: SimpleSDMLayer, FT <: Function, IT <: Number}\n\nThis function will replace the value at any cell by applying the function f to the array of cells values that are within a distance d (in kilometers) from the focal cell. This is, for example, useful to use an average to smooth out the layers. The distance is estimated using the haversine distance, assuming that the radius of the Earth is 6371.0 km. This means that the size of the window will vary a little bit across latitudes, but this is far better than using a number of cells, which would have dramatic consequences near the poles.\n\nIt always returns a SimpleSDMResponse, and the cells containing nothing will also not contain a value in the output. This is different from the behavior of coarsen, which tends to expand the area of the layer in which we have data.\n\nThis function is currently relatively slow. Performance improvements will arrive at some point.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.latitudes","page":"Other operations","title":"SimpleSDMLayers.latitudes","text":"latitudes(layer::T) where {T <: SimpleSDMLayer}\n\nReturns an iterator with the latitudes of the SDM layer passed as its argument. This returns the latitude at the center of each cell in the grid.\n\n\n\n\n\nlatitudes(records::GBIFRecords)\n\nReturns the non-missing latitudes.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.longitudes","page":"Other operations","title":"SimpleSDMLayers.longitudes","text":"longitudes(layer::T) where {T <: SimpleSDMLayer}\n\nReturns an iterator with the longitudes of the SDM layer passed as its argument. This returns the longitudes at the center of each cell in the grid.\n\n\n\n\n\nlongitudes(records::GBIFRecords)\n\nReturns the non-missing longitudes.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.boundingbox","page":"Other operations","title":"SimpleSDMLayers.boundingbox","text":"boundingbox(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the bounding coordinates of a layer as NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.clip","page":"Other operations","title":"SimpleSDMLayers.clip","text":"clip(layer::T, records::GBIF.GBIFRecords)\n\nReturns a clipped version (with a 10% margin) around all occurences in a GBIFRecords collection.\n\n\n\n\n\nclip(layer::T, df::DataFrames.DataFrame; latitude = :latitude, longitude = :longitude) where {T <: SimpleSDMLayer}\n\nReturns a clipped version (with a 10% margin) around all occurences in a DataFrame. Note that the function looks for columns named :latitude and :longitude by default, but these can be changed using the latitude and longitude arguments.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.mask","page":"Other operations","title":"SimpleSDMLayers.mask","text":"mask(l1::T1, l2::T2) where {T1 <: SimpleSDMLayer, T2 <: SimpleSDMLayer}\n\nReturns a copy of the second layer in which the positions for which the first layer is zero (of the appropriate type) or nothing are set to nothing. This is mostly useful in cases where you have a Bool layer.\n\n\n\n\n\nmask(layer::SimpleSDMLayer, records::GBIF.GBIFRecords, element_type::Type=Bool)\n\nCreate a new layer storing information about the presence of occurrences in the cells, either counting (numeric types) or presence-absence-ing (boolean types) them.\n\n\n\n\n\nmask(layer::SimpleSDMLayer, records::GBIF.GBIFRecords, element_type::Type=Bool)\n\nCreate a new layer storing information about the presence of occurrences in the cells, either counting (numeric types) or presence-absence-ing (boolean types) them. Note that the function looks for columns named :latitude and :longitude by default, but these can be changed using the latitude and longitude arguments.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.rescale!","page":"Other operations","title":"SimpleSDMLayers.rescale!","text":"rescale!(layer::TI, template::TJ) where {TI <: SimpleSDMLayer, TJ <: SimpleSDMLayer}\n\nChanges the values of the layer given as its first argument, so that it has the same range as the values of the layer given as its second argument. Modification is done in-place.\n\n\n\n\n\nrescale!(layer::TI, t::Tuple{T,T}) where {TI <: SimpleSDMLayer, T <: Number}\n\nChanges the values of the layer given as its first argument, so that it has the same range as the values given as a tuple of values. Modification is done in-place.\n\n\n\n\n\nrescale!(layer::T, p::Vector{Real}) where {T <: SimpleSDMLayer}\n\nRescale the values of a layer so that they match with the quantiles given in p. Internally, this uses the Statistics.quantile function.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.rescale","page":"Other operations","title":"SimpleSDMLayers.rescale","text":"rescale(layer::TI, template::TJ) where {TI <: SimpleSDMLayer, TJ <: SimpleSDMLayer}\n\nCopying version of rescale!.\n\n\n\n\n\nrescale(layer::TI, t::Tuple{T,T}) where {TI <: SimpleSDMLayer, T <: Number}\n\nCopying version of rescale!.\n\n\n\n\n\nrescale(layer::T, p::Vector{Real}) where {T <: SimpleSDMLayer}\n\nCopying version of rescale!.\n\n\n\n\n\n","category":"function"},{"location":"man/operations/#SimpleSDMLayers.mosaic","page":"Other operations","title":"SimpleSDMLayers.mosaic","text":"mosaic(f::TF, layers::Vector{T}) where {TF <: Function, T <: SimpleSDMLayer}\n\nJoins a series of possibly overlapping layers by applying the function f to the values that occupy the same cells. Note that the function f  should return a single value and accept an vector as input. Functions like Statistics.mean, etc, work well.\n\nUsing mosaic with maximum is equivalent to raster::merge from the R package raster.\n\n\n\n\n\n","category":"function"},{"location":"examples/consensus/#Landcover-consensus","page":"Landcover consensus","title":"Landcover consensus","text":"","category":"section"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"In this example, we will create a consensus map of landcover for Corsica based on the EarthEnv data, and measure the variation within each pixel using the variance. The first step is to load the packages we need, and create a bounding box:","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"using SimpleSDMLayers\nusing Plots\n\nbbox = (left=8.25, right=10.0, bottom=41.2, top=43.2)","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"First, we will download all values for our layers:","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"lc = convert.(Float32, SimpleSDMPredictor(EarthEnv, LandCover, 1:12; full=false, bbox...))","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"To perform the actual analysis, we will define a shannon function, which will return the entropy of the land use categories:","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"function shannon(x)\n    v = filter(n -> n>zero(eltype(x)), x)\n    length(v) == 0 && return NaN\n    v = v ./ sum(v)\n    return -sum(v.*log2.(v))\nend","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"We can then apply these functions using the mosaic method:","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"consensus = mosaic(x -> last(findmax(x)), lc)\nentropy = mosaic(shannon, lc)","category":"page"},{"location":"examples/consensus/","page":"Landcover consensus","title":"Landcover consensus","text":"p1 = plot(consensus, c=:terrain, frame=:none)\np2 = plot(entropy, c=:bamako, frame=:none)\n\nplot(p1, p2)","category":"page"},{"location":"man/data/#Datasets","page":"Data","title":"Datasets","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"The package offers access to bioclimatic and other datasets - they are downloaded, saved to the disk, and then read locally. Please note that some of them require a lot of memory, so make sure your machine can handle them.","category":"page"},{"location":"man/data/","page":"Data","title":"Data","text":"By default, the layers are stored in the assets subfolder of the current project. This being said, the prefered solution is to define a SDMLAYERS_PATH environment variable pointing to a specific path, where the layers will live. This will ensure that they are re-used between projects.","category":"page"},{"location":"man/data/#General-interface","page":"Data","title":"General interface","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"All layers are returned as SimpleSDMPredictor, and therefore constructed by calling the SimpleSDMPredictor function on a LayerProvider and a LayerDataset, possibly with a future climate model and scenario. In all cases, the method accepts either a single layer, or an array of layers.","category":"page"},{"location":"man/data/","page":"Data","title":"Data","text":"Data provider Dataset Layers Future models Future scenarios\nEarthEnv Landcover 12  \nEarthEnv HabitatHeterogeneity 14  \n[WorldClim][worldclim-current] BioClim 19 CMIP6 SharedSocioeconomicPathway\n[CHELSA][chelsa-bioclim] BioClim 12 CMIP5 RepresentativeConcentrationPathway","category":"page"},{"location":"man/data/","page":"Data","title":"Data","text":"[earthenv-landcover]: http://www.earthenv.org/landcover [earthenv-texture]: http://www.earthenv.org/texture [worldclim-current]: https://www.worldclim.org/data/worldclim21.html [chelsa-bioclim]: http://chelsa-climate.org/","category":"page"},{"location":"man/data/#Later-providers","page":"Data","title":"Later providers","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"SimpleSDMLayers.LayerProvider\nWorldClim\nCHELSA\nEarthEnv","category":"page"},{"location":"man/data/#SimpleSDMLayers.LayerProvider","page":"Data","title":"SimpleSDMLayers.LayerProvider","text":"LayerProvider\n\nA LayerProvider is an abstract type used to dispatch the correct call of SimpleSDMPredictor to a specific dataset. A dataset is specified by a LayerProvider and a LayerDataset, as well as optionally one or multiple layers, and future climate information.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.WorldClim","page":"Data","title":"SimpleSDMLayers.WorldClim","text":"WorldClim\n\nTODO WorldClim\n\nThis provider currently offers BioClim data, both historical and future under CMIP6.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.CHELSA","page":"Data","title":"SimpleSDMLayers.CHELSA","text":"CHELSA\n\nTODO CHELSA\n\nThis provider currently offers BioClim data, both historical and future under CMIP5.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.EarthEnv","page":"Data","title":"SimpleSDMLayers.EarthEnv","text":"EarthEnv\n\nData from the earthenv project, all released under a CC-BY-NC license to Tuanmu & Jetz. This provider currently offers LandCover and HabitatHeterogeneity rasters.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#Layer-datasets","page":"Data","title":"Layer datasets","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"SimpleSDMLayers.LayerDataset\nBioClim\nLandCover\nHabitatHeterogeneity","category":"page"},{"location":"man/data/#SimpleSDMLayers.LayerDataset","page":"Data","title":"SimpleSDMLayers.LayerDataset","text":"LayerDataset\n\nA LayerDataset is a specific set of rasters provided by a LayerProvider.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.BioClim","page":"Data","title":"SimpleSDMLayers.BioClim","text":"BioClim\n\nA list of 19 bioclimatic variables derived from the monthly temperature and precipitation data. This dataset is provided by WorldClim and CHELSA, both of which offer future versions under CMIP5 and CMIP6 models.\n\nVariable Description\n1 Annual Mean Temperature\n2 Mean Diurnal Range (Mean of monthly (max temp - min temp))\n3 Isothermality (BIO2/BIO7) (* 100)\n4 Temperature Seasonality (standard deviation *100)\n5 Max Temperature of Warmest Month\n6 Min Temperature of Coldest Month\n7 Temperature Annual Range (BIO5-BIO6)\n8 Mean Temperature of Wettest Quarter\n9 Mean Temperature of Driest Quarter\n10 Mean Temperature of Warmest Quarter\n11 Mean Temperature of Coldest Quarter\n12 Annual Precipitation\n13 Precipitation of Wettest Month\n14 Precipitation of Driest Month\n15 Precipitation Seasonality (Coefficient of Variation)\n16 Precipitation of Wettest Quarter\n17 Precipitation of Driest Quarter\n18 Precipitation of Warmest Quarter\n19 Precipitation of Coldest Quarter\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.LandCover","page":"Data","title":"SimpleSDMLayers.LandCover","text":"LandCover\n\nInformation on land cover, currently only provided by EarthEnv.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.HabitatHeterogeneity","page":"Data","title":"SimpleSDMLayers.HabitatHeterogeneity","text":"HabitatHeterogeneity\n\nInformation on habitat heterogeneity, currently only provided by EarthEnv.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#Future-climate-models","page":"Data","title":"Future climate models","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"SharedSocioeconomicPathway\nRepresentativeConcentrationPathway\nCMIP5\nCMIP6","category":"page"},{"location":"man/data/#SimpleSDMLayers.SharedSocioeconomicPathway","page":"Data","title":"SimpleSDMLayers.SharedSocioeconomicPathway","text":"SharedSocioeconomicPathway\n\nEnumeration of the four SSPs, which can be listed with instances(SharedSocioeconomicPathway). These are meant to be used with CMIP6 models.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.RepresentativeConcentrationPathway","page":"Data","title":"SimpleSDMLayers.RepresentativeConcentrationPathway","text":"RepresentativeConcentrationPathway\n\nEnumeration of the four RCPs, which can be listed with instances(RepresentativeConcentrationPathway). These are meant to be used with CMIP5 models.\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.CMIP5","page":"Data","title":"SimpleSDMLayers.CMIP5","text":"CMIP5\n\nEnumeration of the models from CMIP5, which can be listed with instances(CMIP5).\n\n\n\n\n\n","category":"type"},{"location":"man/data/#SimpleSDMLayers.CMIP6","page":"Data","title":"SimpleSDMLayers.CMIP6","text":"CMIP6\n\nEnumeration of the models from CMIP6, which can be listed with instances(CMIP6).\n\n\n\n\n\n","category":"type"},{"location":"man/data/#File-reading-and-writing","page":"Data","title":"File reading and writing","text":"","category":"section"},{"location":"man/data/","page":"Data","title":"Data","text":"SimpleSDMLayers.ascii\ngeotiff","category":"page"},{"location":"man/data/#SimpleSDMLayers.ascii","page":"Data","title":"SimpleSDMLayers.ascii","text":"ascii(file::AbstractString, datatype::Type{T}=Float64) where {T <: Number}\n\nReads the content of a grid file to a SimpleSDMPredictor, the type of which is given by the datatype argument.\n\n\n\n\n\nascii(layer::SimpleSDMPredictor{T}, file::AbstractString; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrites a layer to a grid file, with a given nodata value. The layer must store numbers.\n\n\n\n\n\nascii(layer::SimpleSDMResponse{T}, file::AbstractString; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrites a layer to a grid file, with a given nodata value. The layer must store numbers.\n\n\n\n\n\n","category":"function"},{"location":"man/data/#SimpleSDMLayers.geotiff","page":"Data","title":"SimpleSDMLayers.geotiff","text":"geotiff(::Type{LT}, file, bandnumber::Integer=1; left=nothing, right=nothing, bottom=nothing, top=nothing) where {LT <: SimpleSDMLayer}\n\nThe geotiff function reads a geotiff file, and returns it as a matrix of the correct type. The optional arguments left, right, bottom, and left are defining the bounding box to read from the file. This is particularly useful if you want to get a small subset from large files.\n\nThe first argument is the type of the SimpleSDMLayer to be returned.\n\n\n\n\n\ngeotiff(file::AbstractString, layer::SimpleSDMPredictor{T}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a single layer to a file, where the nodata field is set to an arbitrary value.\n\n\n\n\n\ngeotiff(file::AbstractString, layers::Vector{SimpleSDMPredictor{T}}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nStores a series of layers in a file, where every layer in a band. See geotiff for other options.\n\n\n\n\n\ngeotiff(file::AbstractString, layer::SimpleSDMResponse{T}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a single SimpleSDMResponse layer to a file.\n\n\n\n\n\ngeotiff(file::AbstractString, layers::Vector{SimpleSDMResponse{T}}; nodata::T=convert(T, -9999)) where {T <: Number}\n\nWrite a vector of SimpleSDMResponse layers to bands in a file.\n\n\n\n\n\n","category":"function"},{"location":"examples/dataframes/#Working-with-DataFrames","page":"DataFrames integration","title":"Working with DataFrames","text":"","category":"section"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"Both SimpleSDMLayers.jl and GBIF.jl offer an optional integration with the DataFrames.jl package. Therefore, our previous example with the kingfisher Megaceryle alcyon could also be approached with a DataFrame-centered workflow.","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"We will illustrate this using the same data and producing the same figures as in the previous example. To do so, we will use GBIF.jl to produce the occurrence DataFrame we will use throughout this example. However, it is also possible to use a DataFrame of your choosing instead of one generated by GBIF.jl, as long as it holds one occurrence per row, a column with the latitude coordinates, and a column with longitude coordinates. For the rest, it can hold whatever information you like. Most of our functions assume by default that the coordinates are stored in columns named :latitude and :longitude (the order doesn't matter), but you can generally specify other names with latitude = :lat in case you don't want to rename them (we will show you how below).","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"So let's start by getting our data:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"# Load packages\nusing SimpleSDMLayers\nusing GBIF\nusing Plots\nusing Statistics\n# Load DataFrames too\nusing DataFrames\n\n# Load environmental data\ntemperature, precipitation = SimpleSDMPredictor(WorldClim, BioClim, [1,12])\n\n# Get GBIF occurrences\nkingfisher = GBIF.taxon(\"Megaceryle alcyon\", strict=true)\nkf_occurrences = occurrences(kingfisher, \n                             \"hasCoordinate\" => \"true\", \n                             \"decimalLatitude\" => (0.0, 65.0), \n                             \"decimalLongitude\" => (-180.0, -50.0), \n                             \"limit\" => 200)\nfor i in 1:4\n  occurrences!(kf_occurrences)\nend\n@info kf_occurrences\n","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"Once the data is loaded, we can easily convert the environmental layers to a DataFrame with the corresponding coordinates. We can do this for a single layer or for multiple layers at the same time:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"# Single layer\ntemperature_df = DataFrame(temperature)\n# Multiple layers\nenv_layers = [temperature, precipitation]\nenv_df = DataFrame(env_layers)\nrename!(env_df, :x1 => :temperature, :x2 => :precipitation)\nfirst(env_df, 5)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"Note that the resulting DataFrame will include missing values for the  elements set to nothing in the layers. We might want to remove those rows  using filter! or dropmissing!:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"dropmissing!(env_df, [:temperature, :precipitation]);\nlast(env_df, 5)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"GBIF.jl allows us to convert a set of occurrences to a DataFrame just as easily:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"kf_df = DataFrame(kf_occurrences)\nlast(kf_df, 5)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"We can then extract the temperature values for all the occurrences.","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"temperature[kf_df]","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"Or we can clip the layers according to the occurrences:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"temperature_clip = clip(temperature, kf_df)\nprecipitation_clip = clip(precipitation, kf_df)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"In case your DataFrame has different column names for the coordinates, for example :lat and :lon, you can clip it like this:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"kf_df_shortnames = rename(kf_df, :latitude => :lat, :longitude => :lon)\nclip(temperature, kf_df_shortnames; latitude = :lat, longitude = :lon)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"We can finally plot the layer and occurrence values in a similar way to any DataFrame or Array.","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"histogram2d(temperature_clip, precipitation_clip, c = :viridis)\nscatter!(temperature_clip[kf_df], precipitation_clip[kf_df], \n         lab= \"\", c = :white, msc = :orange)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"To plot the occurrence values over space, you can use:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"contour(temperature_clip, c = :alpine, title = \"Temperature\", \n        frame = :box, fill = true)\nscatter!(kf_df.longitude, kf_df.latitude, \n         lab = \"\", c = :white, msc = :orange, ms = 2)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"We can finally make a layer with the number of observations per cells:","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"abundance = mask(precipitation_clip, kf_occurrences, Float32)","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"A useful trick to visualize sites with occurrences, in contrast with sites without any occurrence, is to use replace or replace! to set the values returned as 0 or true by the function mask() to nothing. This allows us to first plot a background layer with a uniform colour, covering the whole area to visualize, then plot the occurrence layer on top using a different colour scale.","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"abundance_nozeros = replace(abundance, 0 => nothing)\nplot(precipitation_clip, c = :lightgrey)\nplot!(abundance_nozeros, c = :viridis, clim = extrema(abundance_nozeros))","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"Once again, the cells are rather small, and there are few observations, so this is not necessarily going to be very informative. As in our other example, to get a better sense of the distribution of observations, we can get the average number of observations in a radius of 100km around each cell (we will do so for a zoomed-in part of the map to save time):","category":"page"},{"location":"examples/dataframes/","page":"DataFrames integration","title":"DataFrames integration","text":"zoom = abundance[left = -100.0, right = -75.0, top = 43.0, bottom = 20.0]\nbuffered = slidingwindow(zoom, Statistics.mean, 100.0)\nplot(buffered, c = :lapaz, legend = false, frame = :box)\nscatter!(kf_df.longitude, kf_df.latitude, \n         lab = \"\", c = :white, msc = :orange, ms = 2, alpha = 0.5)","category":"page"},{"location":"sdm/gbif/#Working-with-GBIF-data","page":"GBIF integration","title":"Working with GBIF data","text":"","category":"section"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"In this example, we will see how we can make the packages SimpleSDMLayers and the GBIF.jl package interact. We will specifically plot the relationship between temperature and precipitation for a few occurrences of the kingfisher Megaceryle alcyon.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"using SimpleSDMLayers\nusing GBIF\nusing Plots\nusing Statistics\ntemperature, precipitation = SimpleSDMPredictor(WorldClim, BioClim, [1,12])","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can get some occurrences for the taxon of interest:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"kingfisher = GBIF.taxon(\"Megaceryle alcyon\", strict=true)\nkf_occurrences = occurrences(kingfisher, \"hasCoordinate\" => \"true\", \"decimalLatitude\" => (0.0, 65.0), \"decimalLongitude\" => (-180.0, -50.0), \"limit\" => 200)\n\nfor i in 1:4\n  occurrences!(kf_occurrences)\nend\n\n@info kf_occurrences","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can then extract the temperature for the first occurrence:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"temperature[kf_occurrences[1]]","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"Of course, it would be unwieldy to do this for every occurrence in our dataset, and so we will see a way do it much faster. But first, we do not need the entire surface of the planet to perform our analysis, and so we will instead clip the layers:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"temperature_clip = clip(temperature, kf_occurrences)\nprecipitation_clip = clip(precipitation, kf_occurrences)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"This will make the future queries a little faster. By default, the clip function will ad a 5% margin on every side. To get the values of a layer at every occurrence in a GBIFRecord, we simply pass the records as a position:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"histogram2d(temperature_clip, precipitation_clip, c=:viridis)\nscatter!(temperature_clip[kf_occurrences], precipitation_clip[kf_occurrences], lab=\"\", c=:white, msc=:orange)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"This will return a record of all data for all geo-localized occurrences (i.e. neither the latitude nor the longitude is missing) in a GBIFRecords collection, as an array of the eltype of the layer. Note that the layer values can be nothing, in which case you might need to run filter(!isnothing, temperature_clip[kf_occurrences] for it to work with  the plotting functions.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can also plot the records over space, using the overloads of the latitudes and longitudes functions:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"contour(temperature_clip, c=:alpine, title=\"Precipitation\", frame=:box, fill=true)\nscatter!(longitudes(kf_occurrences), latitudes(kf_occurrences), lab=\"\", c=:white, msc=:orange, ms=2)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"These extensions of SimpleSDMLayers functions to work with the GBIF package are meant to greatly simplify the expression of more complex pipelines, notably for actual species distribution modeling.","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"We can finally make a layer with the number of observations per cells:","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"presabs = mask(precipitation_clip, kf_occurrences, Float32)","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"Because the cells are rather small, and there are few observations, this is not necessarily going to be very informative - to get a better sense of the distribution of observations, we can get the average number of observations in a radius of 100km around each cell (we will do so for a zoomed-in part of the map to save time):","category":"page"},{"location":"sdm/gbif/","page":"GBIF integration","title":"GBIF integration","text":"zoom = presabs[left=-100., right=-75.0, top=43.0, bottom=20.0]\nbuffered = slidingwindow(zoom, Statistics.mean, 100.0)\nplot(buffered, c=:lapaz, legend=false, frame=:box)\nscatter!(longitudes(kf_occurrences), latitudes(kf_occurrences), lab=\"\", c=:white, msc=:orange, ms=2, alpha=0.5)","category":"page"},{"location":"examples/temperature/#Getting-temperature-data","page":"Temperature data","title":"Getting temperature data","text":"","category":"section"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"In this example, we will look at temperature data from the worldclim 2 data, crop it for Western Europe, and then change the resolution to aggregate the data. The first step is to get the worldclim layer for temperature (the codes for each layers are in the function documentation):","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"using SimpleSDMLayers\ntemperature = SimpleSDMPredictor(WorldClim, BioClim, 1)","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"Thanks to the integration with Plots and StatsPlots, we can very rapidly visualize these data:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"using Plots, StatsPlots\nheatmap(temperature, c=:cividis, frame=:box)\nxaxis!(\"Longitude\")\nyaxis!(\"Latitude\")","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"Let's also have a look at the density while we're at it:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"density(temperature, frame=:zerolines, c=:grey, fill=(0, :grey, 0.2), leg=false)\nxaxis!(\"Temperature\", (-50,30))","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"The next step is to clip the data to the region of interest. This requires a the coordinates of the bounding box as two tuples (for longitude and latitude) – we can also make a quick heatmap to see what the region looks like:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"temperature_europe = temperature[left=-11.0, right=31.5, bottom=29.0, top=71.5]\nheatmap(temperature_europe, c=:cividis, aspectratio=1, frame=:box)","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"The next step will be to coarsen these data, which requires to give the number of cells to merge alongside each dimension. This number of cells must be a divider of the grid size, which we can view with:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"size(temperature_europe)","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"In an ideal world, we could want to find a number of cells that is the same both for latitude and longitude, and one approach is to finagle our way into a correct grid by changing the clipping region.","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"In this case, we will use a coarsening scale of (5,5), which gives us a total of 25 cells in the aggregated result. Our aggregation function will be mean (so we report the average temperature across these cells):","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"import Statistics\ntemperature_europe_coarse = coarsen(temperature_europe, Statistics.mean, (5, 5))","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"One again, we can plot these data:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"heatmap(temperature_europe_coarse, aspectratio=1, c=:cividis, frame=:box)","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"Finally, we can compare our different clipping and approximations to the overall dataset:","category":"page"},{"location":"examples/temperature/","page":"Temperature data","title":"Temperature data","text":"density(temperature, frame=:zerolines, c=:grey, fill=(0, :grey, 0.5), lab=\"\")\ndensity!(temperature_europe, c=:black, lab=\"Raw data\")\ndensity!(temperature_europe_coarse, c=:darkgrey, lab=\"Average\")\nxaxis!(\"Temperature\", (-50,30))","category":"page"},{"location":"examples/import/#Importing-and-exporting-your-own-data","page":"Importing and exporting","title":"Importing and exporting your own data","text":"","category":"section"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"It is possible to import your own rasters into a SimpleSDMLayer object and to export SimpleSDMLayer objects to raster files. In this example, we will look at a data file produced by the OmniScape package, and which represents landscape connectivity in the Laurentians region of Québec. This example will also show how we can use the broadcast operation to modify the values of a raster.","category":"page"},{"location":"examples/import/#Importing-data","page":"Importing and exporting","title":"Importing data","text":"","category":"section"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"using SimpleSDMLayers\nusing Plots\nusing StatsBase","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"The file comes with the package itself, so we can read it directly - this is a geotiff file, where values are floating point numbers representing connectivity.","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"file = joinpath(dirname(pathof(SimpleSDMLayers)), \"..\", \"data\", \"connectivity.tiff\")","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"To import this file as a SimpleSDMLayer, we need to call the geotiff function, which assumes a WGS84 projection:","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"mp = geotiff(SimpleSDMPredictor, file)","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"Because this file has raw values, which are not necessarily great for plotting, we will transform it to quantiles, using the rescale function.","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"qmap = rescale!(mp, collect(0.0:0.01:1.0))","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"Finally, we are ready for plotting:","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"plot(qmap, frame=:grid, c=:cork, clim=(0,1))","category":"page"},{"location":"examples/import/#Exporting-data","page":"Importing and exporting","title":"Exporting data","text":"","category":"section"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"geotiff can also be used in the opposite way to write SimpleSDMLayer objects to tiff files. For instance, we might want to keep our layer with quantile values for later on:","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"geotiff(\"layer.tif\", qmap)","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"Note that geotiff can also write multiple layers in a single file (as different bands) as long as they have the same size and the same bounding coordinates. We can then reimport them by specifying the band number.","category":"page"},{"location":"examples/import/","page":"Importing and exporting","title":"Importing and exporting","text":"layers = SimpleSDMPredictor(WorldClim, BioClim, 1:2)\n\ngeotiff(\"stack.tif\", layers)\nlayers = [geotiff(SimpleSDMPredictor, \"stack.tif\", i) for i in 1:2]","category":"page"},{"location":"man/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Layers are represented by a grid, storing the content of cells in a Matrix, and a bounding box indicated by the floating point coordinates of its limits.","category":"page"},{"location":"man/types/#Implemented-types","page":"Types","title":"Implemented types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"SimpleSDMResponse\nSimpleSDMPredictor","category":"page"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMResponse","page":"Types","title":"SimpleSDMLayers.SimpleSDMResponse","text":"A response is a SimpleSDMLayer that is mutable, and is the usual type to store analysis outputs. You can transform a response into a predictor using convert.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMPredictor","page":"Types","title":"SimpleSDMLayers.SimpleSDMPredictor","text":"A predictor is a SimpleSDMLayer that is immutable, and so does not have methods for setindex!, etc. It is a safe way to store values that should not be modified by the analysis. Note that if you are in a bind, the values of the grid field are not immutable, but don't tell anyone we told you. The correct way of handling predictors you need to modify would be to use convert methods.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#Abstract-type","page":"Types","title":"Abstract type","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"SimpleSDMLayer","category":"page"},{"location":"man/types/#SimpleSDMLayers.SimpleSDMLayer","page":"Types","title":"SimpleSDMLayers.SimpleSDMLayer","text":"All types in the package are part of the abstract type SimpleSDMLayer. A SimpleSDMLayer has five core fields: grid is a matrix storing the cells, and left, right, bottom and top are floating point numbers specifying the bounding box.\n\nIt is assumed that the missing values will be represented as nothing, so internally the matrix will have type Union{T, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"#Simple-SDM-Layers-in-*Julia*","page":"Home","title":"Simple SDM Layers in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SimpleSDMLayers provides an interface to facilitate the manipulation of raster data for species distributions modeling in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The two core types of the package are SimpleSDMPredictor and SimpleSDMResponse. The only difference between the two is that predictors are immutable, but responses are. All types belong to the abstract SimpleSDMLayer, and are organised in the same way: a grid field storing a matrix of data (of any type!), and the left, right, bottom, and top coordinates (as floating point values).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course these details are largely irrelevant, since we have overloaded a large number of methods from Base, to make indexing, converting, and modifying data as easy as possible.","category":"page"},{"location":"man/overloads/#Methods-overloaded","page":"Overloads","title":"Methods overloaded","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"To facilitate writing julian code, we have overloaded a number of methods from Base. These methods should remove the need to interact with the grid field directly, and also allow to set and get values using the geographic coordinates (as opposed to the grid positions).","category":"page"},{"location":"man/overloads/#From-Base","page":"Overloads","title":"From Base","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"convert\ncopy\ncollect\neltype\nsize\nstride\neachindex\ngetindex\nsetindex!\nsimilar\nreplace\nreplace!\nBase.sum\nBase.maximum\nBase.minimum\nBase.extrema\nBase.max\nBase.min\n+\n-\n*\n/\n==\nisequal","category":"page"},{"location":"man/overloads/#Base.convert","page":"Overloads","title":"Base.convert","text":"Base.convert(::Type{SimpleSDMResponse}, layer::T) where {T <: SimpleSDMPredictor}\n\nReturns a response with the same grid and bounding box as the predictor.\n\n\n\n\n\nBase.convert(::Type{SimpleSDMPredictor}, layer::T) where {T <: SimpleSDMResponse}\n\nReturns a predictor with the same grid and bounding box as the response.\n\n\n\n\n\nBase.convert(::Type{T}, layer::TL) where {T <: Number, TL <: SimpleSDMLayer}\n\nReturns a copy of the layer with the same type (response or predictor), but the element type has been changed to T (which must be a number). This function is extremely useful (required, in fact) for plotting, as the nothing values are changed to NaN in the heatmaps.\n\n\n\n\n\nBase.convert(::Type{Matrix}, layer::T) where {T <: SimpleSDMLayer}\n\nReturns the grid as an array.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.copy","page":"Overloads","title":"Base.copy","text":"Base.copy(l::T) where {T <: SimpleSDMLayer}\n\nReturns a new copy of the layer, which has the same type.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.collect","page":"Overloads","title":"Base.collect","text":"Base.collect(l::T) where {T <: SimpleSDMLayer}\n\nReturns the non-nothing values of a layer.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.eltype","page":"Overloads","title":"Base.eltype","text":"Base.eltype(layer::SimpleSDMLayer{T}) where {T}\n\nReturns the type of the values stored in the grid, where the Nothing type is omitted.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.size","page":"Overloads","title":"Base.size","text":"Base.size(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the size of the grid.\n\n\n\n\n\nBase.size(layer::T, i...) where {T <: SimpleSDMLayer}\n\nReturns the size of the grid alongside a dimension.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.stride","page":"Overloads","title":"Base.stride","text":"Base.stride(layer::T; dims::Union{Nothing,Integer}=nothing) where {T <: SimpleSDMLayer}\n\nReturns the stride, i.e. half the length, of cell dimensions, possibly alongside a side of the grid. The first position is the length of the longitude cells, the second the latitude.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.eachindex","page":"Overloads","title":"Base.eachindex","text":"Base.eachindex(layer::T) where {T <: SimpleSDMLayer}\n\nReturns the index of the grid.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.getindex","page":"Overloads","title":"Base.getindex","text":"Extracts a  value from a layer by its grid position.\n\n\n\n\n\nBase.getindex(layer::T, i::R, j::R) where {T <: SimpleSDMLayer, R <: UnitRange}\n\nExtracts a series of positions in a layer, and returns a layer corresponding to the result. This is essentially a way to rapidly crop a layer to a given subset of its extent. The i and j arguments are UnitRanges (of Integer).\n\nThe layer returned by this function will have the same type as the layer passed as its argument, but this can be changed using convert. Note that this function performs additional checks to ensure that the range is not empty, and to also ensure that it does not overflows from the size of the layer.\n\n\n\n\n\nBase.getindex(layer::T, longitude::K, latitude::K) where {T <: SimpleSDMLayer, K <: AbstractFloat}\n\nExtracts the value of a layer at a given latitude and longitude. If values outside the range are requested, will return nothing.\n\n\n\n\n\nBase.getindex(layer::T; left=nothing, right=nothing, top=nothing, bottom=nothing) where {T <: SimpleSDMLayer, K <: Union{Nothing,AbstractFloat}}\n\nReturns a subset of the argument layer, where the new limits are given by left, right, top, and bottom. Up to three of these can be omitted, and if so these limits will not be affected.\n\n\n\n\n\nBase.getindex(layer::T, n::NT) where {T <: SimpleSDMLayer, NT <: NamedTuple}\n\nReturns a subset of the argument layer, where the new limits are given in a NamedTuple by left, right, top, and bottom, in any order. Up to three of these can be omitted, and if so these limits will not be affected.\n\n\n\n\n\nBase.getindex(layer1::T1, layer2::T2) where {T1 <: SimpleSDMLayer, T2 <: SimpleSDMLayer}\n\nExtract a layer based on a second layer. Note that the two layers must be compatible, which is to say they must have the same stride and the bounding coordinates of layer2 must be contained in layer1.\n\n\n\n\n\nBase.getindex(p::T, occurrence::GBIF.GBIFRecord) where {T <: SimpleSDMLayer}\n\nExtracts the value of a layer at a given position for a GBIFRecord. If the GBIFRecord has no latitude or longitude, this will return nothing.\n\n\n\n\n\nBase.getindex(layer::T, records::GBIF.GBIFRecords) where {T <: SimpleSDMLayer}\n\nReturns the values of a layer at all occurrences in a GBIFRecords collection.\n\n\n\n\n\nBase.getindex(layer::T, records::Vector{GBIF.GBIFRecord}) where {T <: SimpleSDMLayer}\n\nReturns the values of a layer at all occurrences in a GBIFRecord array.\n\n\n\n\n\nBase.getindex(layer::T, df::DataFrames.DataFrame; latitude = :latitude, longitude = :longitude) where {T <: SimpleSDMLayer}\n\nReturns the values of a layer at all occurrences in a DataFrame. Note that the function looks for columns named :latitude and :longitude by default, but these can be changed using the latitude and longitude arguments.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.setindex!","page":"Overloads","title":"Base.setindex!","text":" Base.setindex!(layer::SimpleSDMResponse{T}, v::T, i...) where {T}\n\nChanges the value of a cell, or a range of cells, as indicated by their grid positions.\n\n\n\n\n\nBase.setindex!(layer::T, v, lon::Float64, lat::Float64) where {T <: SimpleSDMResponse}\n\nChanges the values of the cell including the point at the requested latitude and longitude.\n\n\n\n\n\nBase.setindex!(layer::T, v, record::GBIFRecord) where {T <: SimpleSDMResponse}\n\nChanges the values of the cell including the point at the requested latitude and longitude. Be careful, this function will not update a cell that has nothing.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.similar","page":"Overloads","title":"Base.similar","text":"Base.similar(layer::T, ::Type{TC}) where {TC <: Any, T <: SimpleSDMLayer}\n\nReturns a SimpleSDMResponse of the same dimensions as the original layer, with nothing in the same positions. The rest of the values are replaced by the output of zero(TC), which implies that there must be a way to get a zero for the type. If not, the same result can always be achieved through the use of copy, manual update, and convert.\n\n\n\n\n\nBase.similar(layer::T) where {T <: SimpleSDMLayer}\n\nReturns a SimpleSDMResponse of the same dimensions as the original layer, with nothing in the same positions. The rest of the values are replaced by the output of zero(element_type), which implies that there must be a way to get a zero for the type. If not, the same result can always be achieved through the use of copy, manual update, and convert.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.replace","page":"Overloads","title":"Base.replace","text":"Base.replace(layer::T, old_new::Pair...) where {T <: SimpleSDMResponse}\n\nReplaces the elements of layer according to a series of pairs. Returns a copy.\n\n\n\n\n\nBase.replace(layer::T, old_new::Pair...) where {T <: SimpleSDMPredictor}\n\nReplaces the elements of layer according to a series of pairs. Copies the layer as a response before.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.replace!","page":"Overloads","title":"Base.replace!","text":"Base.replace!(layer::T, old_new::Pair...) where {T <: SimpleSDMLayer}\n\nReplaces the elements of layer according to a series of pairs. In place. Only possible for SimpleSDMResponse elements (which are mutable) and will throw an error if called on a SimpleSDMPredictor element (which is not mutable).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.sum","page":"Overloads","title":"Base.sum","text":"Base.sum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies sum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.sum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies sum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.maximum","page":"Overloads","title":"Base.maximum","text":"Base.maximum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies maximum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.maximum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies maximum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.minimum","page":"Overloads","title":"Base.minimum","text":"Base.minimum(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies minimum (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.minimum(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies minimum (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.extrema","page":"Overloads","title":"Base.extrema","text":"Base.extrema(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies extrema (from Base) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nBase.extrema(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies extrema (from Base) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.max","page":"Overloads","title":"Base.max","text":"Base.max(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies max (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that max is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.min","page":"Overloads","title":"Base.min","text":"Base.min(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies min (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that min is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:+","page":"Overloads","title":"Base.:+","text":"Base.+(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies + (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that + is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:-","page":"Overloads","title":"Base.:-","text":"Base.-(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies - (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that - is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:*","page":"Overloads","title":"Base.:*","text":"Base.*(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies * (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that * is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:/","page":"Overloads","title":"Base.:/","text":"Base./(l1::SimpleSDMLayer, l2::SimpleSDMLayer)\n\nApplies / (from Base) to every pair of cells from two SimpleSDMLayers and returns the result as a new SimpleSDMResponse layer. Note that / is only applied to the pairs without a nothing element, and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.:==","page":"Overloads","title":"Base.:==","text":"==(layer1::SimpleSDMLayer, layer2::SimpleSDMLayer)\n\nTests whether two SimpleSDMLayer elements are equal. The layers are equal if  all their fields (grid, left, right, bottom, top) are equal, as  verified with == (e.g., layer1.grid == layer2.grid).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Base.isequal","page":"Overloads","title":"Base.isequal","text":"isequal(layer1::SimpleSDMLayer, layer2::SimpleSDMLayer)\n\nTests whether two SimpleSDMLayer elements are equal. The layers are equal if  all their fields (grid, left, right, bottom, top) are equal, as  verified with isequal (e.g., isequal(layer1.grid, layer2.grid)).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#From-Broadcast","page":"Overloads","title":"From Broadcast","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"broadcast","category":"page"},{"location":"man/overloads/#Base.Broadcast.broadcast","page":"Overloads","title":"Base.Broadcast.broadcast","text":"Broadcast.broadcast(f, L::LT) where {LT <: SimpleSDMLayer}\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#From-Statistics","page":"Overloads","title":"From Statistics","text":"","category":"section"},{"location":"man/overloads/","page":"Overloads","title":"Overloads","text":"Statistics.mean\nStatistics.median\nStatistics.std\nStatistics.quantile","category":"page"},{"location":"man/overloads/#Statistics.mean","page":"Overloads","title":"Statistics.mean","text":"Statistics.mean(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies mean (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.mean(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies mean (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.mean(layers::Array{T}) where {T <: SimpleSDMLayer}\n\nApplies mean (from Statistics) to the elements in corresponding positions from the different layers (similar to mean(a::Array{Matrix})) and returns the result as a new SimpleSDMResponse layer. Note that mean is only applied to the positions  without a nothing element and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.median","page":"Overloads","title":"Statistics.median","text":"Statistics.median(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies median (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.median(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies median (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.std","page":"Overloads","title":"Statistics.std","text":"Statistics.std(l::SimpleSDMResponse{T}) where {T <: Number}\n\nApplies std (from Statistics) to an object of type SimpleSDMResponse. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.std(l::SimpleSDMPredictor{T}) where {T <: Number}\n\nApplies std (from Statistics) to an object of type SimpleSDMPredictor. This function has been automatically generated. Note that this function is only applied to the non-nothing elements of the layer, and has no method to work on the dims keyword; the grid itself can be extracted with convert(Matrix, l).\n\n\n\n\n\nStatistics.std(layers::Array{T}) where {T <: SimpleSDMLayer}\n\nApplies std (from Statistics) to the elements in corresponding positions from the different layers (similar to mean(a::Array{Matrix})) and returns the result as a new SimpleSDMResponse layer. Note that std is only applied to the positions  without a nothing element and returns nothing for the pairs with one. This function has been automatically generated.\n\n\n\n\n\n","category":"function"},{"location":"man/overloads/#Statistics.quantile","page":"Overloads","title":"Statistics.quantile","text":"quantile(layer::T, p) where {T <: SimpleSDMLayer}\n\nReturns the quantiles of layer at p, using Statistics.quantile.\n\n\n\n\n\n","category":"function"}]
}
